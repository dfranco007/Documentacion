\chapter{Introducción}

Este proyecto se ha desarrollado para dar respuesta a un proyecto emergente dentro de la fundación Donostia International Physics Center (DIPC) llamado Morfokinetics. Por ello, ciertas de las actividades a desarrollar han sido propuestas por dicho proyecto ya que son necesarias para su avance y desarrollo. Así pues, se ha mantenido contacto con el director del proyecto interno del DIPC durante el ciclo de vida de este proyecto.

El objetivo de este proyecto es el análisis computacional y experimental de la segmentación de imágenes, en este caso, producidas mediante la deposición química de vapor de materiales sintetizados. En el tratamiento de estas imágenes, aparte del objetivo principal de poder encontrar los diferentes elementos que se encuentran en ella, también se presentan varias tareas complementarias: porcentaje de recubrimiento de los elementos encontrados, aislamiento y densidad espectral de cada elemento. 

Una vez realizadas estas tareas, se requiere paralelizar el tipo de técnica de segmentación escogida para poder minimizar el tiempo de espera al resultado por parte del usuario (cliente) o, incluso, poder tratar los \textit{frames} de una secuencia de vídeo de manera que se pueda dar una respuesta en tiempo real.

\section{Motivación}

Como se explicará más adelante en el apartado \ref{cap:EvoSeg} la segmentación de imágenes es algo que ha avanzado mucho durante las últimas décadas. Esto se debe a que muchas de las tecnologías que utilizamos diariamente hacen uso en cierta manera de la segmentación de imagen para realizar ciertas funciones. La segmentación de imagen está presente en la  detección de movimiento de objetos, en sistemas de posicionamiento humano, en las consolas, en aplicaciones fotográficas en las que se detectan los rostros humanos o se reconocen objetos, en imágenes de satélites espaciales para la predicción meteorológica, en la localización de tumores u otros síntomas patológicos en radiografías médicas etc. 

Aparte de ayudar a mejorar ciertas funciones de la vida cotidiana, la segmentación se ha vuelto en muchos campos, como la medicina, indispensable para hacer ciertos trabajos. Por no decir, que es la pieza clave en trabajos como la cirugía robotizada, ya que es necesario que, al estar realizando la operación, se detecten con precisión todas las partes físicas del cuerpo humano para no poner en riesgo la vida del paciente. Otra utilidad también sería la reconstrucción craneal y/o cerebral en 3D de pacientes.

Las técnicas de segmentación más avanzadas consiguen información detallada sobre la imagen tratada logrando así un resultado mejor, sin embargo cuanta más precisión se necesita más costoso es el algoritmo. Por lo tanto, muchas veces se suele buscar un equilibrio entre la precisión necesaria y la respuesta temporal mínima exigida a la hora de elegir un algoritmo adecuado. Por esta razón, hay muchos trabajos que tratan de mejorar esta respuesta temporal de los algoritmos de segmentación en base a optimizaciones. El resultado son miles de artículos relacionados con implementaciones paralelas e implementaciones en GPU (\textit{Graphics Processing Unit}) aparte de optimizaciones matemáticas y algorítmicas. 

En conclusión, la paralelización de métodos de segmentación está a la <<orden del día>> puesto que es necesaria una respuesta rápida en determinados ámbitos de uso. Este trabajo pretende crear una versión paralela robusta sobre una aproximación al método de \textit{level set} para proporcionar una respuesta rápida sobre este tipo de segmentación. 


\section{Estructura de la memoria}


Este documento está estructurado en varios apartados. 

La primera parte de la documentación es el entorno de investigación del proyecto que está formada por el primer, segundo, tercer y cuarto capítulo. Se presentan varios conceptos básicos: la definición de la segmentación y la evolución histórica de ésta. Realizada esta introducción, se comentan las aplicaciones que hoy en día tiene este ámbito que, como se podrá observar, serán muchas. Con esta primera parte se espera poder ubicar al lector sobre este análisis de imágenes, pieza angular de este proyecto, para que pueda entender correctamente el resto de la documentación. Más adelante se presenta una clasificación de los diferentes tipos de segmentación de imágenes, explicando individualmente sus características y algunos trabajos que se hayan realizado de estas técnicas. El final de esta primera parte se centra en una técnica de segmentación concreta: \textit{level set}. Se comentarán variaciones de la técnica y mejoras hasta llegar a una aproximación la cuál mejorará el tiempo de ejecución significativamente y con la que se ha trabajado en el proyecto. El desarrollo realizado en este proyecto está basado en el trabajo publicado en \cite{ofeli}. 

En la segunda parte del documento, formada por el quinto, sexto y séptimo capítulo, se encuentra todo lo relacionado con la paralelización de la técnica utilizada. La primera toma de contacto o la primera propuesta de paralelización creada, las posteriores fases desarrolladas, las conclusiones y decisiones tomadas en cada fase y el rendimiento obtenido en la versión final.

En la tercera y última parte, formada por el octavo y noveno capítulo, se presentan las conclusiones del trabajo realizado, algunos aspectos de la gestión del mismo y varias propuesta de mejora. Al final del documento puede encontrarse la bibliografía y los anexos.


\section{Objetivos y necesidades del cliente} 

La primera toma de contacto con el director del proyecto Morfokinetics de la fundación del DIPC fue en el mes de febrero. Parte de ese proyecto lo realizó la compañera Estíbaliz Sánchez, por lo que se encontrará más información general de él en la memoria de su PFG \cite{esti}. A lo largo de la documentación de este PFG el director del proyecto Morfokinetics aparecerá nombrado como el cliente, ya que es la persona a la que se le dará respuesta cumpliendo los objetivos de este proyecto.

En el proyecto Morfokinetics hay una parte en la que es necesario realizar un tratamiento de una imagen para sacar de ésta varias conclusiones. El cliente conoce la teoría sobre un algoritmo llamado \textit{level set} que realiza segmentación de imágenes con bastante precisión y que está bastante extendido. Sin embargo, no conoce ninguna implementación de este algoritmo ni el tiempo que puede costar realizar dicha segmentación. Recordando la introducción del proyecto, las imágenes se han sacado de una proyección en cierta lámina de materiales sintetizados mediante la deposición química de vapor, por lo que tendrán una apariencia similar a las presentadas en la figura \ref{ejemploImagenes}. La principal tarea u objetivo que se deberá realizar en este proyecto para satisfacer las necesidades del cliente es la siguiente:

\begin{enumerate}
		\item Realizar la segmentación lo más rápidamente posible. De esta manera la técnica de segmentación podrá ser capaz de analizar un vídeo de la evolución de la deposición de estos materiales \textit{frame} a \textit{frame}.
\end{enumerate}

 Aparte del principal objetivo, el cliente también necesita varias tareas alternativas una vez realizada la segmentación de la imagen:
 
\begin{enumerate}
	\item Determinar el número de islas existentes
	\item Porcentaje de recubrimiento de las islas respecto al tamaño de la imagen
	\item Aislamiento de cada isla 
	\item Densidad espectral de cada isla
	\item Por todo ello, habrá que encontrar las islas\protect\footnotemark contenidas en la imagen
\end{enumerate}
\footnotetext{se llamará <<isla>> a cada superficie que se distinga sobre el fondo de la imagen. Ver ejemplo en \ref{ejemplo1}}

\begin{figure}[H]
	\captionsetup{justification=centering}	
	\begin{center}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.9\textwidth]{./imagenes/ejemplo1}
			\subcaption{}\label{ejemplo1}
		\end{subfigure}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.9\textwidth]{./imagenes/ejemplo2}
			\subcaption{}\label{ejemplo2}
		\end{subfigure}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.9\textwidth]{./imagenes/ejemplo3}
			\subcaption{}\label{ejemplo3}
		\end{subfigure}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.9\textwidth]{./imagenes/ejemplo4}
			\subcaption{}\label{ejemplo4}
		\end{subfigure}
	\end{center}
	\caption{Ejemplo de proyecciones en láminas de materiales sintetizados mediante la deposición química de vapor}	
	\label{ejemploImagenes}
\end{figure}
Las islas puede que estén muy separadas, como se puede ver en la imagen \ref{ejemplo1} o muy juntas como en la imagen \ref{ejemplo3}. También se puede observar que la forma de estas islas no es siempre la misma. Estas características dependen de ciertas variables físicas que hacen que el material se <<pegue>> de una determinada manera en la lámina, dando lugar a estas imágenes abstractas.









\chapter{Conceptos básicos}

\section{Definición de segmentación}

La segmentación de imagen, también denominada a veces como \textit{labelling}, es el proceso de dividir la imagen en grupos o regiones contiguas cuyos elementos(p. e. píxeles o \textit{voxels}) tienen propiedades o características comunes. Estas regiones servirán para identificar los objetos de la imagen que posteriormente podrán ser clasificados y etiquetados en base a sus propiedades \cite{terry1}. 

El resultado final de la segmentación de la imagen será un conjunto de regiones o segmentos que formarán la imagen original. Cada uno de los píxeles de una región tendrá una característica común con los píxeles de dicha región y una diferencia significativa respecto a píxeles de otra región, por ello se habrán agrupado en distinto segmento, ya sea por ejemplo, en el color, la textura o la intensidad. Por lo tanto, se podrán extraer los segmentos de interés de la imagen, es decir, los objetos que ésta contiene.

\section{Evolución de la segmentación}\label{cap:EvoSeg}

Los primeros desarrollos en el ámbito de la segmentación de imagen se remontan a hace 50 años. En 1965 se desarrolló un operador para detectar bordes entre diferentes partes de una imagen, conocido como \textit{Roberts operator} o \textit{Roberts Edge Detector}. Este detector fue el primer paso hacia la descomposición de imágenes en diferentes segmentos o regiones. En esa misma década también se propusieron varios detectores de bordes como \textit{Sobel} y \textit{Prewitt edge detectors}. A partir de ahí, comenzaron a surgir diferentes algoritmos y técnicas de segmentación. Junto con esto, también se amplió el ámbito de estas técnicas: de imagen 2D a 3D, de imágenes fijas a imágenes en <<movimiento>> o secuencias de imágenes, de escalas de gris a imágenes a color etc \cite{zhang1}.

A pesar de los años de investigación dedicados a estas técnicas y el gran número de ellas existentes, la segmentación de imagen sigue siendo un tema de investigación desafiante y no existe aún un estándar de segmentación que funcione bien para cualquier tipo de imagen. Estas técnicas están en continua evolución y aún están lejos de su madurez. Prueba de ello está en que muchas conferencias del ámbito de tratamiento de imagen tienen apartados de segmentación, además, el número de artículos de este ámbito aumenta cada año y muchos libros de procesamiento de imagen tienen capítulos referidos a la segmentación \cite{zhang1}.

Para que el lector se haga una idea, se ha realizado una búsqueda en el sitio web \textit{ieee explore}\cite{ieee1} con las palabras <<image segmentation>> en varios años. Este buscador encuentra artículos, conferencias, estándares, libros, revistas y cursos de aprendizaje relacionados con las palabras introducidas. La figura \ref{regisIEEE} muestra el número de resultados de esa búsqueda desde 1960 hasta 2015. Como se puede observar, el número de resultados aumenta notablemente cada lustro.	
	
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{./imagenes/publicaciones}
	\captionsetup{justification=centering}
	\caption{Resultados de búsqueda en el sitio web \textit{ieee explore} \cite{ieee1} con las palabras <<image segmentation>> }
	\vspace{2 mm}			
	Fuente: \cite{ieee1}
	\label{regisIEEE}
\end{figure}
 
\section{Aplicaciones}

Las aplicaciones de segmentación de imágenes son muchas y muy diversas. Cualquier proceso que requiera la extracción de información de una imagen utilizará, en cierta medida, una técnica de segmentación. A continuación nombraremos algunas de las aplicaciones que se han ido recopilando en la realización de esta documentación, aunque el número de aplicaciones totales es mucho mayor:

\begin{itemize}
	\item Localización de moléculas en imágenes microscópicas.
	\item Aplicaciones médicas.
			\begin{itemize}
				\item Localización de tumores y otras patologías.
			\end{itemize}
	\item Detección de cuerpos para aplicaciones de seguimiento de movimientos como Kinect.
		\begin{itemize}
			\item Operaciones guiadas por ordenador.
		\end{itemize}
	\item Localización de objetos en imágenes de satélite.
	\item Visión por computador.
	\item Reconocimientos faciales.
	\item Reconocimiento de plantas
\end{itemize}







\chapter{Técnicas de segmentación}

\section{Introducción}

Hay bastante controversia en cuanto a la clasificación de las diferentes técnicas de segmentación, por el gran número de estas técnicas existentes, por las diferentes maneras en las que cada una tiene representada la imagen, las diferentes características que utilizan de la imagen etc. Hay trabajos que realizan una clasificación de los algoritmos desde dos puntos de vista diferentes: en función de cómo puede ser utilizado el algoritmo, es decir, las aplicaciones que pueda tener, y otra en base al algoritmo en sí, fijándose en cómo realiza la segmentación \cite{mc1}. Por otro lado, también hay otros trabajos que realizan esta clasificación para ámbitos muy concretos \cite[pag. 11]{mc1}.

\textit{Zhang}\cite{zhang1} propone una clasificación más clara, creando la división en dos grupos: a) algoritmos basados en detectar la discontinuidad de las diferentes regiones de la imagen, los llamados \textit{edge-based algorithms} b) basados en detectar la continuidad o la similitud de las regiones, los llamados \textit{region-based algorithms}. Posteriormente hace una subdivisión de estos dos grupos en función de la estrategia de procesamiento: los que realizan un procesamiento secuencial, donde el procesamiento de pasos previos se tienen en cuenta en pasos posteriores, y los que realizan un procesamiento paralelo, es decir, decisiones independientes y simultáneas \cite{zhang1}.

\begin{figure}[ht]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=1\textwidth]{./imagenes/tecnicasSegmentacion2}
	\caption{Clasificación de las técnicas de segmentación}
	\vspace{2 mm}			
	Fuente: \cite{basa1}
	\label{tecnicasSegmentacion}
\end{figure}

La clasificación elegida tiene varios aspectos en común con la última presentada y descrita \cite{basa1}. Se ha preferido esta clasificación al ser clara en cuanto a la división de las técnicas y las características que éstas tienen frente a otras clasificaciones. En la figura  \ref{tecnicasSegmentacion} se muestra el esquema de la clasificación elegida.

\section{Segmentación de imagen basada en el tratamiento de los \textit{píxeles}}\label{cap:tratPixel}

Este tipo de segmentación consiste en dividir la imagen en segmentos o  conjuntos de píxeles (conocidos como <<superpíxeles>>). Cada píxel de la imagen será tratado y agrupado en función de sus características. Existen varios subgrupos dentro de esta clasificación: \textit{Thresholding},o <<Método del valor umbral>> en castellano, y \textit{Clustering}, o algoritmos de agrupamiento en castellano, entre otros.

\subsection{Thresholding}

Este tipo de segmentación es la más simple de todas y se basa en clasificar los píxeles en dos grupos en función de la intensidad de éstos: los que superan la intensidad umbral definida y los que no la superan. El resultado de esta segmentación sería una imagen binaria (véase la comparación de las figuras \ref{thresholding1} y \ref{thresholding2}). 

Esta técnica puede ser definida como:

\

Para una imagen NxM :

for $i = 1,2, ... , N \ $and$ \ j = 1,2, ... , M $
\begin{equation}
 f(n) = \left\{ 
\begin{array}{l l}
1 & \quad \mathrm{si \ I(i,j) \ge T}\\
0 & \quad \mathrm{si \ I(i,j) <\ T}
\end{array} \right. 
\end{equation}
donde $I(i,j)$ es el valor del píxel de la posición i,j de la imagen.

También existe la posibilidad de definir varias intensidades umbrales (véase la comparación de las figuras \ref{thresholding3} y \ref{thresholding4}), con el fin de particionar la imagen en más segmentos. En sí, se podrán definir tantos umbrales como niveles de gris contiene la imagen, aunque habrá que buscar un buen equilibrio. 

La ventaja de este tipo de segmentación es que es relativamente sencilla comparada con otros tipos de segmentación más avanzada como \textit{watershed} o \textit{level set}. Aun así, esta segmentación funciona bien cuando el fondo y los objetos siguen una distribución bimodal, es decir, que hay una diferencia <<notable>> entre las dos partes. Comúnmente esta característica no se da en todas las imágenes, por lo que no tendrá buenos resultados en las que el fondo no se distinga bien de los objetos \cite{basa1}. Además, esta segmentación tampoco se comporta bien con imágenes que tienen una iluminación gradiente grande (véase la comparación de las figuras \ref{thresholding5} y \ref{thresholding6}). Aunque es verdad que para ello también existen varias mejoras que hacen que la segmentación se <<adapte>> para conseguir mejores resultados.

En la figura \ref{tecnicasSegmentacion} se muestran varias subclases de \textit{thresholding}. Aunque no se explicarán en profundidad conviene saber que hay varias maneras de realizar esta segmentación. Primeramente se nombra el método de Otso, \textit{Otsu's method} en inglés, que adapta el umbral en función de la dispersión de los niveles de gris. El segundo método, el \textit{Global}, es el más simple y el que hemos estado explicando hasta ahora. Y por último, el método \textit{Adaptative}, mencionado anteriormente, que se adapta a la intensidad de la imagen.

\begin{figure}[H]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=.65\textwidth]{./imagenes/imageHistogram}
	\caption{Histograma que muestra tres aparentes segmentos de la imagen con dos umbrales}
	\vspace{2 mm}					
	Fuente: \cite{basa1}	
	\label{imageHistogram}
\end{figure}

Las figuras \ref{thresHold1}, \ref{thresHold2} y \ref{thresHold3} muestran varios ejemplos de segmentación utilizando \textit{thresholding}.
\vspace{-2 mm}			
\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/thresholding1}
		\subcaption{Imagen original}\label{thresholding1}		
	\end{subfigure}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/thresholding2}
		\subcaption{Imagen segmentada}\label{thresholding2}
	\end{subfigure}
	\caption{Segmentación con \textit{thresholding}}	
	\vspace{2 mm}			
	Fuente: commons.wikimedia.org	
	\label{thresHold1}
\end{figure}	
\begin{figure}[H]	
	\captionsetup{justification=centering}	
	\centering	
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/thresholding3}
		\subcaption{Imagen original}\label{thresholding3}
	\end{subfigure}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/thresholding4}
		\subcaption{Imagen segmentada}\label{thresholding4}
	\end{subfigure}
	\caption{Segmentación con \textit{thresholding} con varios umbrales}
	\vspace{2 mm}			
	Fuente: \textit{rosavallsformacio.tv} y \textit{photo-kako.com} para la realización de la segmentación
	\label{thresHold2}
\end{figure}	
\begin{figure}[H]
	\centering
	\captionsetup{justification=centering}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.7\textwidth]{./imagenes/thresholding5}
		\subcaption{Imagen original}\label{thresholding5}
	\end{subfigure}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.7\textwidth]{./imagenes/thresholding6}
		\subcaption{Imagen segmentada}\label{thresholding6}
	\end{subfigure}
	\caption{Segmentación con \textit{thresholding} en imagen con iluminación gradiente}
	\vspace{2 mm}			
	Fuente: \textit{homepages.inf.ed.ac.uk/rbf/HIPR2/}
	\label{thresHold3}
\end{figure}


\subsection{Clustering}

Junto con la técnica de \textit{thresholding} el \textit{clustering} es la técnica de segmentación más utilizada. En general esta técnica divide los puntos en varios \textit{clusters} o grupos en función de la distancia entre ellos. En este caso concreto, los puntos serán los píxeles de la imagen y la distancia entre ellos estará relacionada con la intensidad, color y textura, pudiendo combinar varios de estos factores. 

Los algoritmos de \textit{clustering} se pueden dividir entre jerárquicos y particionales, donde la principal diferencia entre los dos está en el modo en que se construyen los grupos. Los algoritmos jerárquicos suelen ser más precisos, sin embargo, no valen para una cantidad de datos grande como en una imagen ya que el coste computacional es muy elevado. Por lo tanto, la opción escogida suele ser el \textit{clustering} particional. No obstante, esta técnica tiene varias desventajas \cite{oli1}:

\begin{enumerate}
	\item Generalmente es necesario saber previamente el número de \textit{clusters} que hay en la imagen. 
	\item No utilizan información espacial inherente a la imagen.
	\item En algunos algoritmos de clustering, como el K-means que se explicará a continuación, no se asegura un resultado óptimo, ya que distintas inicializaciones dan diferentes resultados.
\end{enumerate} 

En la clasificación presentada en la figura \ref{tecnicasSegmentacion} se muestran varias subclases de la técnica de \textit{clustering} que corresponden a diferentes algoritmos de creación de \textit{clusters}. El algoritmo \textit{Fuzzy C-Means} agrupa los píxeles utilizando la lógica difusa, donde cada píxel tendrá un grado de pertenencia a todos los \textit{clusters}. En general, hay muchos tipos de técnicas de clustering por lo que las técnicas restantes se agruparán en la sección de \textit{Others} de la figura \ref{tecnicasSegmentacion}. El algoritmo K-means es el más utilizado (véase ejemplos de su segmentación en las figuras \ref{clusteringTotal1} y \ref{clusteringTotal2}). Una descripción de su modo de funcionamiento a grandes rasgos sería:

\begin{enumerate}
 \item Se asignan \textit{K} primeros píxeles como centroides.
 \item Se agrupan los píxeles, restantes con los centroides definidos en función de la distancia con estos.
 \item Se calculan los nuevos \textit{K} centroides como los baricentros de los \textit{K} conglomerados obtenidos.
 \item Se alternan los pasos 2 y 3 hasta que se alcance un determinado criterio de convergencia (máxima variación de centroides, por ejemplo).
\end{enumerate}

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/clustering1}
		\subcaption{Imagen original}\label{clustering1}
	\end{subfigure}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/clustering2}
		\subcaption{Imagen segmentada}\label{clustering2}
	\end{subfigure}
	\caption{Segmentación utilizando K-means con K=16}
	\vspace{2 mm}
	\label{clusteringTotal1}			
	Fuente: commons.wikipedia.org
\end{figure}
\begin{figure}[H]
	\centering
	\captionsetup{justification=centering}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=1\textwidth]{./imagenes/clustering3}
		\subcaption{Imagen original}\label{clustering3}
	\end{subfigure}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=1\textwidth]{./imagenes/clustering4}
		\subcaption{Imagen segmentada}\label{clustering4}
	\end{subfigure}
	\caption{Segmentación utilizando K-means con K=6}
	\vspace{2 mm}
	\label{clusteringTotal2}			
	Fuente: \textit{imagedatabase.cs.washington.edu/demo/kmcluster/}
\end{figure}

\subsection{Morphology}

La técnica de la morfología, o \textit{morphology} en inglés, se clasificaría dentro de las técnicas basadas en el tratamiento de los píxeles. Hay varios métodos de morfología y se basan en una máscara llamada \textit{structuring element} para investigar cada píxel. El valor de cada píxel está determinado por el de sus vecinos que pertenecen a esa máscara. Los métodos más simples de esta técnica son la dilatación y la erosión. Para una imagen binaria, la dilatación convierte en uno todos los píxeles de la máscara si los píxeles <<debajo>> del píxel central son ceros como se muestra en la imagen \ref{morphology1}. La erosión es el caso contrario, es decir, convierte en ceros todos los elementos de la máscara si esta contiene algún elemento que sea cero. La combinación de estas simples operaciones junto con otras como el complemento, la unión y la intersección, pueden utilizarse para realizar operaciones más avanzadas y complejas. 
 
\begin{figure}[ht]
	\centering
	\captionsetup{justification=centering}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.8\textwidth]{./imagenes/morphology1-1}
		\subcaption{Imagen sin tratar}\label{morphology1.1}
	\end{subfigure}	
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.8\textwidth]{./imagenes/morphology1-2}
		\subcaption{Resultado de la dilatación}\label{morphology1.2}
	\end{subfigure}
	\caption{Ejemplo de dilatación de la técnica de morfología}
	\vspace{2 mm}
	Fuente: \cite{eri2015}
	\label{morphology1}
\end{figure}

\section{Segmentación de imagen basada en la detección de bordes}

Este tipo de segmentación consiste en encontrar los bordes de los objetos contenidos en la imagen con el fin de poder dividir la imagen en función de los bordes encontrados. Los detectores de bordes tradicionales suelen utilizar los operadores diferenciales de detección de bordes comentados en \ref{cap:EvoSeg}, es decir, los operadores \textit{Sobel}, \textit{Roberts} y \textit{Prewitt edge detectors} que están basados en el gradiente de la función de intensidad de una imagen. Normalmente los bordes suelen detectarse en las intersecciones de dos regiones de la imagen que tienen diferentes intensidades.

La ventaja de este tipo de segmentación frente a la basada en el tratamiento de píxeles es que, aparte de hacer la división de las diferentes regiones, sabremos exactamente dónde se encuentran los bordes de éstas, siendo útil para poder extraerlas y poder tratarlas individualmente. Por lo tanto, esta técnica funcionará mejor cuando la diferencia entre las regiones tenga buena calidad. Una de las posibles <<desventajas>> puede ser que la detección de muchos bordes dificulte la extracción de las regiones de interés.

Existen varios subgrupos dentro de esta clasificación: \textit{Edge detection} o <<Detección de bordes>> en castellano, técnicas que tienen que ver con el gradiente de la imagen \textit{Gradient mode}, \textit{Active contours} o <<Contornos activos>> y \textit{level sets} o técnicas del <<Conjunto de nivel>>.

\subsection{Detección de borde usando gradientes}

En la figura \ref{tecnicasSegmentacion} se diferencian las dos primeras clasificaciones \textit{Edge detection} y \textit{Gradient mode} pero al estar directamente relacionadas se ha decidido explicarlas en conjunto. 

Las técnicas clásicas de detección de bordes se basan en encontrar la derivada respecto a los ejes que forman la imagen, o dicho de otro modo, el gradiente. El gradiente de un punto de una función escalar, representado con $\nabla$, se representa en forma vectorial. Este vector indica la dirección en la cual la función varia más rápidamente y su módulo representa el ritmo de variación de la función en la dirección de dicho vector. Este módulo se utilizará para determinar si un punto es borde o no, en función de si supera un valor umbral dado. Para encontrar la máxima variación en ese punto se deben de hacer las derivadas parciales respecto a cada eje y coger el máximo valor de éstas. En general el gradiente se suele aproximar con la fórmula\protect\footnotemark \footnotetext{Válida para una imagen de dos dimensiones. En caso de tener tres dimensiones la fórmula sería $|G| \approx |G_x| + |G_y| + |G_z| $ }$|G| \approx |G_x| + |G_y| $  que es mucho más simple de implementar en la práctica. Valiéndonos de esto, se desarrollaron los primeros operadores diferenciales ya comentados  \textit{Sobel}, \textit{Roberts} y \textit{Prewitt edge detectors} (véase un ejemplo de cada segmentación en la figura \ref{prewittTable2}). Estos operadores no son más que máscaras aplicadas al píxel a tratar y a cierta vecindad de éste para calcular una aproximación a dichas derivadas $G_x$ y $G_y$. De ahí el nombrarlos como <<operadores>>.

\

\subsubsection{$\blacksquare$ \quad Roberts operator}

Este operador es el más simple de los tres mencionados y aproxima las derivadas tomando la diferencia de dos valores contiguos. La gran desventaja de este operador es que es muy sensible al ruido al tratar pocos vecinos y sólo permite marcar los puntos del borde pero no su orientación. A pesar de todo ello, es un operador que computacionalmente es poco costoso debido a su simpleza y que trabaja bien con imágenes binarias. Véase las máscaras utilizadas por esta técnica presentada en la tabla \ref{robetsTable}. 

\begin{table}[H]
	\parbox{.65\linewidth}{
		\centering
		\begin{tabular}{|c|c|}
			\hline
			+1 & 0 \\ \hline
			0  & -1 \\ \hline
		\end{tabular}
		\caption*{$G_x$}
	}
	\hspace*{-50mm}
	\parbox{.65\linewidth}{
		\centering
		\begin{tabular}{|c|c|}
			\hline
			0 & +1 \\ \hline
			-1  & 0 \\ \hline
		\end{tabular}
		\caption*{$G_y$}
	}
	\captionsetup{justification=centering}
	\caption{Máscaras utilizadas por el operador de Roberts de tamaño 2x2}
	\label{robetsTable}
\end{table}

\subsubsection{$\blacksquare$ \quad Sobel operator}

Este operador utiliza una máscara más grande que el \textit{Roberts operator}, 3x3, por lo que implicará a más vecinos. Enfatiza más los píxeles de alrededor del centro. La ventaja de este operador es que es menos sensible al ruido, detecta muy bien los bordes horizontales y verticales y además proporciona un suavizado. Las desventaja de este operador es que computacionalmente es más costoso, no tiene buena detección de bordes diagonales y no da información sobre la orientación del borde. Véase las máscaras utilizadas por esta técnica presentada en la tabla \ref{sobelTable}.
\begin{table}[H]
	\parbox{.45\linewidth}{
	\centering
		\begin{tabular}{|c|c|c|}
			\hline
			-1 & 0 & +1 \\ \hline
			-2 & 0 & +2 \\ \hline
			-1 & 0 & +1 \\ \hline
		\end{tabular}
	\caption*{$G_x$}
	}
	\parbox{.45\linewidth}{
	\centering
		\begin{tabular}{|c|c|c|}
			\hline
			+1 & +2 & +1 \\ \hline
			0  & 0  & 0  \\ \hline
			-1 & -2 & -1 \\ \hline
		\end{tabular}
		\caption*{$G_y$}
	}
	\captionsetup{justification=centering}
	\caption{Máscaras utilizadas por el operador de Sobel de tamaño 3x3}
	\label{sobelTable}
\end{table}

\subsubsection{$\blacksquare$ \quad Prewitt operator}

Este operador es parecido al operador de Sobel pero este no enfatiza los píxeles cercanos al centro y los coeficientes son diferentes. Las ventajas son que aumenta la respuesta a los bordes diagonales poniéndole peso a píxeles vecinos que antes no tenían, tiene poca sensibilidad la ruido y proporciona la magnitud y orientación del borde (hasta 8 direcciones). Véase las máscaras utilizadas por esta técnica presentada en las tablas \ref{prewittTable1} y \ref{prewittTable2}.
 \begin{table}[H]
 	\parbox{.45\linewidth}{
 		\centering
		\begin{tabular}{|c|c|c|}
			\hline
			-1 & +1 & +1 \\ \hline
			-1 & -2 & +2 \\ \hline
			-1 & +1 & +1 \\ \hline
		\end{tabular}
 		\caption*{0}
 	}
 	\parbox{.45\linewidth}{
 		\centering
			\begin{tabular}{|c|c|c|}
				\hline
				+1 & +1 & +1 \\ \hline
				-1 & -2 & +1 \\ \hline
				-1 & +1 & +1 \\ \hline
			\end{tabular}
 		\caption*{45}
 	}
	\captionsetup{justification=centering}
 	\caption{Máscaras utilizadas por el operador de Prewitt de tamaño 3x3}
	\label{prewittTable1}
 \end{table}

\begin{figure}[H]
	\captionsetup{justification=centering}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/operator0}
		\subcaption{Imagen original}\label{operator0}
	\end{subfigure}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/operator1}
		\subcaption{Resultado de \textit{Roberts operator}}\label{operator1}
	\end{subfigure}
	
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/operator2}
		\subcaption{Resultado de \textit{Sovel operator}}\label{operator2}
	\end{subfigure}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/operator3}
		\subcaption{Resultado de \textit{Prewitt operator}}\label{operator3}
	\end{subfigure}
	\caption{Detección de bordes con el uso de los operadores}
	\vspace{2 mm}
	\centering
	\label{prewittTable2}
	Fuente: commons.wikipedia.org
\end{figure}

\subsection{Active Contours}\label{cap:actContour}

Desde que fueron introducidos por Kass y colaboradores en 1988 \cite{kass1}, los contornos activos o más comúnmente nombrados como \textit{Snakes}, han ganado popularidad gracias a los buenos resultados que se pueden llegar a obtener en la segmentación de imágenes. 

Un contorno activo o \textit{Snake} es una curva elástica que comienza a moverse dada una posición inicial de manera que llegue a delimitar las regiones de interés de la imagen. La curva se irá moviendo de manera que se minimice su energía hasta llegar a un punto de convergencia. El contorno puede ser definido paramétricamente como $V(s) = [x(s),y(s)]$ donde $x(s)$ e $y(s)$ son las coordenadas de la parte $s$ del contorno. La energía del contorno está compuesta por una energía interna y otra externa, $E_{int}$ y $E_{ext}$ respectivamente. La definición formal sería:

\begin{equation}
E = \int_{0}^{1}E_{int}(v,s) + E_{ext}(v(s)) ds
\end{equation}

$E_{int}$ da las características de deformación del contorno elástico, por lo tanto depende de la forma que éste tenga. La $E_{int}$ puede ser definida como:
\begin{equation}
E_{int} = \frac{1}{2} (\alpha|\frac{\delta v}{\delta s}|^2 + \beta|\frac{\delta^2 v}{\delta s^2}| ^2)
\end{equation}
y los valores $\alpha$ y $\beta$ determinan el grado en el que el contorno se puede estirar o curvar. Un aumento en la magnitud $\alpha$ incrementaría la tensión de la curva y un aumento de $\beta$ incrementaría la rigidez de la curva, haciendo que sea menos flexible.

En cuanto a la energía externa hay varias maneras de definirla. Una elección popular sería la magnitud negativa del gradiente de la imagen que se definiría como:
\begin{equation}
E_{int}(\vec{x}) = - |\nabla [G_{\alpha} I(\vec{x})]|^2
\end{equation}
donde $G_{\alpha}$ es una convolución con un filtro pasa bajo gaussiano. Esta propuesta de energía hace que el contorno se expanda hasta los bordes que haya en la imagen como se puede ver en la figura \ref{activeContour1}.
\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/activeContour1-1}
		\subcaption{}\label{activeContour1.1}
	\end{subfigure}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/activeContour1-2}
		\subcaption{}\label{activeContour1.2}
	\end{subfigure}
	\caption{Ejemplo de un contorno activo}
	\vspace{2 mm}
	Fuente: \cite{eri2015}
	\label{activeContour1}
\end{figure}

La imagen \ref{activeContour1.1} corresponde a la imagen de entrada, mientras que la imagen \ref{activeContour1.2} corresponde a la convolución de la magnitud gradiente de la imagen de entrada con un filtro pasa bajo gaussiano. La línea interior (roja) en la imagen \ref{activeContour1.2} es el contorno activo que se moverá hasta la línea exterior (verde) que corresponde con el borde de la imagen original. Un ejemplo de la aplicación de esta técnica se puede ver en la figura \ref{activeContour2}.

\begin{figure}[H]
	\captionsetup{justification=centering}	
	\centering
	\includegraphics[width=.8\textwidth]{./imagenes/activeContour2}
	\caption{Ejemplo de segmentación de plantas presentando en \cite{suta1} utilizando los contornos activos}
	\vspace{2 mm}
	Fuente: \cite{suta1}	
	\label{activeContour2}
\end{figure}


\subsection{\textit{Level set}}\label{levelSet}
Conjuntos de nivel, o \textit{level set} en inglés, es un tipo de segmentación muy parecida a la que hemos explicado en la sección \ref{cap:actContour} ya que también se trata de expandir un contorno dado previamente para encontrar los bordes de la imagen. La ventaja de este método frente al referido es que permite juntar y dividir contornos sin ningún cálculo extra necesario.

El contorno está representado por la función de \textit{level set}, que está definida en una dimensión más que las dimensiones de la imagen a segmentar, es decir, para una imagen 2D tendríamos una superficie de \textit{level set} de tres dimensiones mientras que para una imagen de 3D tendríamos una superficie de 4D. En el caso de una superficie de 3D ésta tiene una forma cónica como se puede ver en la figura \ref{levelSet1}. Suponiendo entonces que la imagen a tratar tiene dos dimensiones, podríamos definir la función de \textit{level set} como $z = \phi(x,y,t)$ que devuelve la altura de la superficie de \textit{level set} en el punto $(x,y)$ del plano de la imagen en el tiempo $t$. El contorno es definido implícitamente como <<zero \textit{level set}>>, donde la altura del plano respecto a la superficie es cero ($\phi(x,y,t) = 0$). Esto es justo la intersección entre el plano de la imagen y la superficie. Véase las figuras \ref{levelSet1} y \ref{levelSet2} para ver ilustraciones de la técnica de \textit{level set}.

\

Para propagar el contorno se mueve la superficie de \textit{level set} en el eje z, como se puede ver en la figura \ref{levelSet1}. La rapidez y la dirección en la que se mueve el contorno está determinada por como se curva la superficie de \textit{level set}. Suponiendo que cada punto del contorno se mueve en una dirección ortogonal frente al contorno con una velocidad F, el contorno evoluciona usando la siguiente PDE (\textit{partial differential equation} o ecuación en derivadas parciales en castellano):

\begin{equation}
\frac{\delta \phi(x,y,t)}{\delta t} = F(x,y,I) |\nabla \phi(x,y,t)|
\end{equation}

Esta función de velocidad varía dependiendo del punto de la imagen I a tratar y hace que el contorno se expanda a ciertas áreas de la imagen y no lo haga en otras zonas de esta. Normalmente la función de velocidad se define por la intensidad o el gradiente de los píxeles y por la curva de la función de \textit{level set}.

De la idea de que modificaciones de píxeles lejanos al contorno no afectan a este surgen varias mejoras de esta técnica que tienen en cuenta los píxeles con los que se trabajará en cada iteración: \textit{narrow band} y \textit{sparse field methods}. El método de \textit{narrow band} actualiza los píxeles en una línea estrecha alrededor del contorno. El método \textit{sparse field} actualiza los píxeles vecinos del contorno únicamente.

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.7\textwidth]{./imagenes/levelSet1}
	\caption{Ilustración de la superficie de \textit{level set}}
	\vspace{2 mm}
	Fuente: \cite{eri2015}
	\label{levelSet1}
\end{figure}
\

\

\

\

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.7\textwidth]{./imagenes/levelSet2}
	\caption{Ilustración del método de \textit{level set}}
	\vspace{2 mm}
	Fuente: commons.wikipedia.org
	\label{levelSet2}
\end{figure}

\section{Segmentación de imagen basada en regiones crecientes}\label{cap:segRegiCreci}

Este tipo de segmentación, más conocida como \textit{region growing}, se basa en la idea de que los píxeles de una región tienen características comunes, como puede ser, la intensidad de gris etc. Por ello, al tener que tratar un nuevo píxel si este tiene una intensidad de gris parecida a la intensidad de grises que contiene la región significará que ese punto pertenece a ella. 

Existen varios subgrupos dentro de esta clasificación: técnicas basadas en la idea de regiones crecientes, o \textit{region growing} en inglés, técnicas de \textit{Split/Merge} y técnicas basadas en grafos \textit{Graphs cuts}.

\subsection{\textit{Region growing}}

Este subgrupo agrupa todos las técnicas que siguen la idea de agrupar los píxeles con características comunes, como el nivel de gris o el color de éstos. Hay dos técnicas conocidas que siguen esta metodología, por lo que en esta ocasión explicaremos más de una técnica de este subgrupo de segmentación.

\subsubsection{$\blacksquare$ \quad \textit{Region growing} o \textit{Seeded-based region growing segmentation}}

Este tipo de segmentación comienza con la selección de un píxel, denominado a menudo como semilla o \textit{seed} en inglés, que está dentro del objeto de interés. Normalmente la semilla se elige manualmente. A partir de ese píxel semilla (primer punto de la región) se comenzará a extender la región procesando sus vecinos y añadiéndolos en base a un criterio predefinido. Este criterio de inserción será en base a la intensidad, color o textura de la semilla y los puntos que pertenezcan a la región. Cada vez que se inserta un nuevo punto a la región la característica que se esté utilizando para realizar la inserción se volverá a calcular, por ejemplo, si se utiliza el nivel de gris, se volverá a calcular el valor medio de los niveles de gris que hay en la región generada hasta el momento. De esta manera, la región se irá expandiendo añadiendo vecinos hasta que encuentre alguno que no cumpla con la condición de inserción impuesta por el criterio. Si un punto no ha sido añadido a ninguna región se podrá añadir a una región cercana suya si la diferencia entre, por ejemplo, el nivel de gris de este punto y el nivel de gris medio de la región no supera un valor umbral \textit{T} dado. Véase un ejemplo de esta técnica en la figura \ref{regionGrowing1}.

Esta técnica es útil cuando la intensidad del fondo y del objeto son muy parecidas pero están separadas por un borde <<notable>> o por otra región.
\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.4\textwidth]{./imagenes/regionGrowing1}
	\caption{Ejemplo del funcionamiento de la técnica de \textit{region growing}}
	\vspace{2 mm}
	Fuente: \cite{eri2015}
	\label{regionGrowing1}
\end{figure}
\

\

\

\begin{figure}[H]
	\captionsetup{justification=centering}
	\begin{center}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.9\textwidth]{./imagenes/regionGrowing6}
			\subcaption{Imagen original}\label{regionGrowing6}
		\end{subfigure}
	\end{center}	
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/regionGrowing2}
		\subcaption{\textit{Region growing} con un valor umbral T=255}\label{regionGrowing2}
	\end{subfigure}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/regionGrowing3}
		\subcaption{\textit{Region growing} con un valor umbral T=225}\label{regionGrowing3}
	\end{subfigure}	
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/regionGrowing4}
		\subcaption{\textit{Region growing} con un valor umbral T=190}\label{regionGrowing4}
	\end{subfigure}
	\begin{subfigure}[t]{2.5in}
		\centering
		\includegraphics[width=.9\textwidth]{./imagenes/regionGrowing5}
		\subcaption{\textit{Region growing} con un valor umbral T=155}\label{regionGrowing5}
	\end{subfigure}
	\caption{Ejemplo de la técnica de \textit{region growing}}
	\centering
	\vspace{2 mm}
	\label{regionGrowingEntera}
	Fuente: commons.wikipedia.org
\end{figure}

En la figura \ref{regionGrowingEntera} se puede ver un ejemplo de la técnica de \textit{region growing} donde se quiere encontrar la parte del rayo más fuerte en la imagen. Para ello se eligen como semilla los puntos con mayor valor de gris posible(255). El criterio de inserción de los píxeles es tener el "mismo" nivel de gris. En este caso se ha decidido que los puntos que no han sido insertados en una región se inserten en una cercana si superan el valor umbral \textit{T} dado. Por ello en \ref{regionGrowing2} solo aparecen los puntos semilla ya que no se habrán unido puntos con este criterio y el valor \textit{T} es demasiado alto. En las imágenes \ref{regionGrowing3}, \ref{regionGrowing4} y \ref{regionGrowing5} ese valor \textit{T} se va disminuyendo y cada vez se insertan más puntos en la región. 

\

\

\subsubsection{$\blacksquare$ \quad \textit{Watershed}}

La idea principal de esta técnica se basa en ver la imagen como una imagen tridimensional donde la tercera dimensión es la altura del píxel. La altura del píxel está determinada por su nivel de gris. Topológicamente quedará algo como se puede ver en \ref{watershed1}. En este <<terreno>> creado se podrán diferenciar hasta tres puntos. Estos puntos son determinados con la analogía de como una gota de agua caería y se movería si se precipitase en ese punto. Hay tres tipos de puntos:
\begin{enumerate}
	\item Puntos con un nivel de gris mínimo local donde la gota se estancaría.
	\item Puntos en los que la gota caería o se deslizaría hacia un único punto mínimo local.
	\item Puntos en los que la gota podría caer hacia más de un punto mínimo local.
\end{enumerate}
El segundo tipo de puntos son nombrados como \textit{watershed} ,o cuencas en castellano, y los del tercer tipo son nombrados como \textit{watersheds lines}, bordes o líneas de las cuencas en castellano.

El objetivo final de esta técnica será encontrar los bordes de las cuencas, que representarán los bordes de la imagen original. Para ello existen varias maneras de hacerlo, la más común es la técnica de \textit{flooding}. La idea es simple, imaginemos que se empieza a echar agua en los puntos de tipo uno, es decir, los que representan un mínimo local y son <<cuencas>>. El nivel del agua empezará a subir hasta que llegue a un punto en el que la cuenca se empiece a desbordar y vaya a juntarse con otra cuenca. En ese momento, se construye una presa o un muro de manera que el agua no se desborde. Esas presas o muros construidos serán los bordes de las cuencas. Con todas estas presas se habrá conseguido la segmentación de la imagen.

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.7\textwidth]{./imagenes/watershed1}
	\caption{Ejemplo del funcionamiento de la técnica de \textit{watershed}}
	\vspace{2 mm}
	Fuente: \cite{eri2015}
	\label{watershed1}
\end{figure}
En la figura \ref{watershed2} se puede ver el un ejemplo del funcionamiento de la técnica de \textit{watershed} donde la intensidad de los píxeles de la imagen de la izquierda serán la altura de ese mismo punto en la imagen derecha, creando así ese terreno.

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.8\textwidth]{./imagenes/watershed2}
	\caption{Funcionamiento de la técnica de \textit{watershed}}
	\vspace{2 mm}	
	Fuente: \textit{http://www.di.ubi.pt/$\sim$agomes/cvm/teoricas/07-regionsegmentation.pdf}	
	\label{watershed2}
\end{figure}

En la figura \ref{watershed3} se muestra el funcionamiento de la técnica de \textit{watershed} donde se puede ver como va creciendo el nivel de agua hasta encontrar ese <<punto>> de desbordamiento en el que se marcan los bordes.

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.6\textwidth]{./imagenes/watershed3}
	\caption{Funcionamiento de la técnica de \textit{watershed}}
	\vspace{2 mm}		
	Fuente: \textit{http://www.di.ubi.pt/$\sim$agomes/cvm/teoricas/07-regionsegmentation.pdf}
	\label{watershed3}
\end{figure}

\subsection{\textit{Split/Merge}}

La técnica de \textit{split}, a diferencia de la técnica de \textit{region growing} que empieza con una serie de puntos <<semilla>>, empieza con la imagen entera como una única región y va subdividiendo la imagen recursivamente en regiones más pequeñas en base a un criterio de homogeneidad.

En cuanto a la técnica de \textit{merge}, es lo contrario que la de \textit{split}, ya que esta empieza con pequeñas regiones de 2x2 o 4x4 y las va juntando entre sí en base a si tienen o no características comunes entre ellas como el nivel de gris, el color, la textura etc.

\subsection{\textit{Graph cut}}

La idea principal de este tipo de segmentación es representar la imagen a tratar como un grafo, donde normalmente cada píxel es un nodo y tienen aristas con los nodos vecinos. La ventaja de estos algoritmos está en que pueden llegar a trabajar bien incluso si la separación entre dos regiones está <<rota>> o es dudosa. Hay varios algoritmos distintos dentro de esta clasificación, en este caso se ha seleccionado el método de segmentación de \textit{Markov}, o \textit{Markov random field (MRF) segmentation} y concretamente una variante de este llamada \textit{graph cut}. 

MRF considera a cada píxel como un nodo del grafo y tienen aristas con cada píxel vecino. Sin embargo, cada nodo tiene dos conexiones más a un par de nodos especiales llamados \textit{source} (S) y \textit{sink} (T) como se muestra en la figura \ref{graphCuts1}. Se les añade un peso a las aristas entre los nodos de manera que los píxeles que pertenecen al fondo tienen un peso pequeño en la arista que los une con uno de esos dos nodos anteriores y un peso grande con el otro nodo. De forma inversa, los píxeles que pertenezcan al primer plano tendrán un peso pequeño con uno de ellos y un peso grande con el otro. Por otro lado, los pesos de las aristas entre los píxeles son grandes cuando éstos tienen características comunes y un peso pequeño en caso contrario.

La segmentación se realiza aplicando un algoritmo de corte de grafos. El objetivo es minimizar la suma de las aristas por las que se va a cortar el grafo, para ello hay varios algoritmos para buscar el mínimo corte ha realizar.

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.5\textwidth]{./imagenes/graphCuts1}
	\caption{Funcionamiento de la técnica de \textit{graph cut} en una imagen 3x3}
	\vspace{2 mm}		
	Fuente: \cite{eri2015}
	\label{graphCuts1}
\end{figure}

\section{Conclusiones de los tipos de segmentación}\label{sec:conclusiones}

Como se ha podido ver a lo largo de este capítulo, hay muchos tipos de técnicas de segmentación de imágenes. Además, existen más técnicas de segmentación que no se han explicado en este trabajo ya que se han añadido las más conocidas y populares con el fin de establecer una base para el lector. 

Aparte de las técnicas que no se han explicado hay que decir que existen muchas mejoras, optimizaciones y variantes de todas las técnicas de segmentación. Por ello, en este trabajo se han explicado las ideas principales de los algoritmos sin tener en cuenta ésto ya que el trabajo se habría extendido demasiado.









\chapter{Optimizaciones y mejoras del algoritmo \textit{level set} original} 


El algoritmo \textit{level set} es uno de los más utilizados  como consecuencia del buen rendimiento que obtiene al segmentar imágenes. Existen optimizaciones que lo hacen muy eficiente, como el trabajo que se presentará a continuación \cite{yong1}, que será capaz de satisfacer la demanda que requiere este proyecto.

\

\

\section{Introducción}

Como se ha dado a conocer en el apartado \ref{sec:conclusiones} hay muchos tipos de mejoras y optimizaciones de cada técnica de segmentación existentes. A la hora de afrontar el problema que el cliente proponía se tenía que elegir un tipo de segmentación de las técnicas estudiadas. Entre todas ellas se escogió el algoritmo \textit{level set}, por ser un algoritmo de segmentación eficiente ampliamente utilizado, lo que facilitaría la búsqueda de información sobre él. Además, el cliente recomendaba esta técnica, ya que aseguraba que se iban a obtener buenos resultados con ella.

Repasando este algoritmo, las ventajas que tiene son que la segmentación conseguida es precisa y que no añade sobrecoste al hacer la división o unión del contorno. Sin embargo, el algoritmo se basa en la resolución de ecuaciones diferenciales, lo que supone que el algoritmo sea costoso y lento. Se han desarrollado varias implementaciones en GPU \cite{eri2015}, también sobre imágenes 3D \cite{aaron1}, y en proyectos de fin de carrera también se utilizan GPUs \cite{cudaseg} etc. De la misma manera, también se han desarrollado paralelizaciones del algoritmo para arquitecturas SMP(\textit{Symmetric Multi-Processing}) \cite{jeon1} o para arquitecturas de memoria distribuida con MPI(\textit{Message Passing Interface})  \cite{moha1}. 

Hay muchos artículos sobre este algoritmo, alguna implementación paralela realizada sobre el algoritmo original y, por lo tanto, a pesar de la paralelización, los tiempos que obtienen siguen siendo elevados para las restricciones de este proyecto. Estas paralelizaciones y otras técnicas de optimización se centran siempre en resolver las PDEs asociadas a la evolución del \textit{level set}. Sin embargo, para muchos problemas de imagen, como la segmentación, no es necesario tanta precisión, ya que el objetivo final es encontrar los bordes de los objetos. En este caso, la evolución del proceso no tiene tanto interés como el resultado final. Siguiendo esta idea Shi y Karl presentaron un artículo muy interesante que será la base de la segmentación realizada en este proyecto \cite{yong1}.

\

\

\section{Aproximación a la técnica de \textit{level set}}

Como se ha mencionado anteriormente para el objetivo de este proyecto, no se tienen por qué resolver las PDEs en el algoritmo \textit{level set} ya que, para una segmentación, importa más el resultado final que la evolución propia del algoritmo. Además, la resolución de las PDEs conlleva que se tengan que realizar reinicializaciones de la función de \textit{level set} (representada con la letra $\phi$) lo que implica aún más cálculo. El trabajo presentado por Shi y Karl \cite{yong1} elimina la reinicialización al tener una colección de enteros (los cuales representan la función $\phi$) que cambian dinámicamente según va propagándose el contorno y, además, no calculan las PDEs. Estas dos mejoras elementales hace que su algoritmo sea mucho más rápido que el \textit{level set} original. 

En este trabajo se presenta una nueva estrategia de implementación del método de \textit{level set}. Para el caso de un espacio euclídeo de dos dimensiones, una curva C es representada implícitamente como el \textit{zero level set} de una función $\phi$ definida en una cuadrícula como se muestra en la figura \ref{aproxLevelSet}. La función $\phi$ tendrá un valor negativo dentro de la curva C y un valor positivo fuera de ella, por eso se dice que representa implícitamente a la curva C. 

Se definen dos listas de vecindad en esta cuadrícula, $L_{in}$ y $L_{out}$. En la imagen se puede ver que el movimiento de la curva C se puede conseguir moviendo un punto de una lista a otra.

Se asume que la función $\phi$ está definida sobre un dominio $D \subset R^k$ y está discretizada sobre una rejilla de tamaño $M_1 \times M_2 \times ... \times M_k$. Estando entonces en una representación de dos dimensiones, y siguiendo el ejemplo de la rejilla mostrada anteriormente se pueden definir dos listas de vecindad del contorno C: $L_{in}$ y $L_{out}$.

\

$L_{in} = \{x \ | \ \phi(x) < 0$ y $  \exists y \in N(x)$ tal que $\phi(y) > 0\}$

\

$L_{out} = \{x \ | \ \phi(x) > 0$ y $  \exists y \in N(x)$ tal que $\phi(y) < 0\}$

\

\begin{figure}[H]
	\captionsetup{justification=centering}	
	\begin{center}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=1\textwidth]{./imagenes/aproxLevelSet1}
			\subcaption{}\label{aproxLevelSet1}
		\end{subfigure}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=1\textwidth]{./imagenes/aproxLevelSet2}	
			\subcaption{}\label{aproxLevelSet2}
		\end{subfigure}
	\end{center}
	\caption{Representación de la curva C}
	\vspace{2 mm}		
	\centering
	Fuente: \cite{yong1}	
	\label{aproxLevelSet}
\end{figure}	

Siendo x una coordenada de la rejilla denotada como $x = {x_1,x_2,...,x_k}$ y $N(x)$ como un vecino de x con valor discreto definido como:
\begin{equation}
N(x) = \{y \in D \ | \ \sum_{k=1}^{K} |y_k - x_k| = 1\}  \ \forall x \in D
\end{equation}

Como podemos observar en la figura \ref{aproxLevelSet} la lista $L_{in}$ está formada por los puntos de la rejilla que están dentro de la curva C y $L_{out}$ está formada por los puntos de la rejilla que están fuera de C. Por lo tanto, como se puede ver en las definiciones formales de las listas, cada punto de ellas tiene que tener un punto vecino de la otra lista, de manera que las dos estén "pegadas".

Recordando lo visto en la sección de explicación del \textit{level set}(\ref{levelSet}) en el clásico \textit{level set} la siguiente PDE es resuelta para evolucionar el contorno C bajo una función de velocidad F:
\begin{equation}\label{speedLevelSet}
\frac{d\phi}{dt} + F|\nabla \phi| = 0
\end{equation}
La figura \ref{aproxLevelSet2} muestra el proceso evolutivo de la curva C de la figura \ref{aproxLevelSet1}. En el punto marcado como A la curva se ha movido hacia fuera lo que ha modificado el valor de la función $\phi$ de positivo a negativo. En el punto B la curva se ha movido hacia dentro, partiendo la curva en dos y cambiando el valor de la función $\phi$ de negativo a positivo. Todo esto también ocurre en el \textit{level set} original, con la diferencia de que la resolución de la PDE mostrada en la ecuación \ref{speedLevelSet} tiene un coste elevado. Se consiguen los mismos resultados finales fácilmente si se usa la relación entre C, $L_{in}$ y $L_{out}$. Para mover la curva hacia fuera en el punto A de la rejilla tendremos que pasar el punto de la lista $L_{out}$ a $L_{in}$. De manera similar, para mover la curva hacia dentro en el punto B tendremos que cambiar el punto B de $L_{in}$ a $L_{out}$. En general, con aplicar dichas operaciones se va moviendo la curva hacia cualquier punto con el mínimo coste operacional. 


\subsubsection{Algoritmo}

Para la realización del algoritmo son necesarias estas estructuras:

\begin{itemize}
	\item Un array para la función de \textit{level set }$\phi$;
	\item Un array para la velocidad (F) con la que se propagará la curva;
	\item Dos listas de vecindad de la curva: $L_{in}$ y $L_{out}$.	
\end{itemize}

Nombraremos a los puntos que están dentro de C pero no en la lista $L_{in}$ como <<puntos interiores>> y a los que están fuera de C pero que no pertenecen a $L_{out}$ como <<puntos exteriores>>. Para agilizar aún más el cálculo, los valores que puede tomar la función $\phi$ son cuatro enteros: {-3, -1, 1, 3}.
\begin{equation}
\phi (x) = 
\left \{
\begin{array}{rcl}
3 & si & x \mbox{ es un punto exterior} \\
1 & si & x \in L_{out} \\ 
-1 & si & x \in L_{in} \\
-3 & si & x \mbox{ es un punto interior}
\end{array}
\right .
\end{equation}

 Para la función F de velocidad sólo se usa el signo, por lo que también es un \textit{array} de enteros con los valores: {1, 0, -1}. En cuanto a las listas, son listas ligadas de manera que la inserción y el borrado de puntos se pueden hacer de manera rápida. 
 
 Antes de presentar el algoritmo se aclararán ciertas cuestiones. Para empezar, hay dos operaciones básicas que se utilizan en el algoritmo:
 
 \begin{itemize}
 	\item  La operación \textit{switch\_in()} para un punto x $\in L_{out}$ se define como:
 	switch\_in(x):
 	\begin{itemize}
 		\item Paso 1: Se quita el punto de $L_{out}$ y se pasa a $L_{in}$. Se cambia el valor de $\phi$ en ese punto: $\phi$(x) = -1.
 		\item Paso 2: Se añaden los puntos vecinos de x a $L_{out}$ y se cambian sus respectivos valores en $\phi$. Más formalmente: $\forall y$ $\in$ N(x) que satisfaga $\phi(y) = 3$ se añade $y$ a $L_{out}$ y se pone $\phi(y) = 1$
 	\end{itemize}
 	Con esta operación se mueve el contorno un punto de la rejilla hacia fuera. 
 	\item Similarmente se define la operación \textit{switch\_out()} para un punto x $\in$ $L_{in}$:
 	 switch\_out(x): 	 
 	 \begin{itemize}
 	 	\item Paso 1: Se quita el punto de  $L_{in}$ y se pasa a $L_{out}$. Se cambia el valor de $\phi$ en ese punto: $\phi$(x) = 1.
 	 	\item Paso 2: Se añaden los puntos vecinos de x a $L_{in}$ y se cambia sus respectivos valores en $\phi$. Más formalmente: $\forall y $ $\in$ N(x) que satisfaga $\phi(y) = -3$ se añade $y$ a $L_{out}$ y se pone $\phi(y) = -1$
 	 \end{itemize}
 	Con esta operación se mueve el contorno un punto de la rejilla hacia dentro. 
 \end{itemize}

Por otro lado, la función F de velocidad presentada antes, normalmente se suele separar en dos velocidades: $F_{ext}$ que depende de los datos y $F_{int}$ para la realización de un suavizado del contorno. La velocidad $F_{int}$ es normalmente la curvatura de la curva \cite{chan}. Sin embargo, esta evaluación de la curva usando la función $\phi$ suele ser computacionalmente costosa. Tras varios pasos esta función de velocidad $F_{int}$ puede llegar a ser determinada por un filtro Gaussiano que puede ser aproximado con operaciones con enteros, por lo que se reduce el cómputo. Además, al separar las dos velocidades, no tiene por qué hacerse el suavizado después de cada iteración de evolución del contorno como en otros trabajos \cite{yong1}, sino que se realizará cuando se satisfaga cierta condición, lo que reduce aún más el coste. Con esto entonces, el algoritmo tendrá dos ciclos principales: el primer ciclo en el que se expandirá o evolucionará el contorno y el segundo ciclo (que se realizará de vez en cuando) en el que se suavizará el contorno para que se siga expandiendo con normalidad. 


\begin{table}[H]
	\small
	\centering
	\begin{tabular}{|l|}
		\hline		
		\tabitem Paso 1: Inicializar el <<array>> $\phi$, $F_{ext}$ y las dos listas $L_{out}$ y $L_{in}$. \\
		\tabitem Paso 2: Primer ciclo donde se escanean las dos listas para actualizar $\phi$, $L_{out}$ y $L_{in}$. \\
		\quad \quad \quad \quad - Se calcula la velocidad para cada punto de $L_{out}$ y $L_{in}$. \\
		\quad \quad \quad \quad - Evolución hacia fuera. Recorremos la lista $L_{out}$ y se hace  la operación \\ 
		\quad \quad \quad \quad \ \ \textit{switch\_in(x)} $\forall x \in L_{out}$ si $F_{ext}$(x) $>$ 0. \\ 
		\quad \quad \quad \quad - Se eliminan los puntos redundantes en $L_{in}$ (véase la figura \ref{switchLevelSet}).\\ 
		\quad \quad \quad \quad \ \ Para ello se tendrá que recorrer la lista y para cada punto $x \in L_{in}$,\\
		\quad \quad \quad \quad \ \ si $\forall y \in N(x); \phi(y) < 0$, se borra $x$ de $L_{in}$ y se cambia $\phi(x) = -3$. \\ 
		\quad \quad \quad \quad - Evolución hacia dentro. Recorremos la lista $L_{in}$ y se hace  la operación \\ 
		\quad \quad \quad \quad \ \ \textit{switch\_out(x)} $\forall x \in L_{in}$ si F(x) $<$ 0. \\ 
		\quad \quad \quad \quad - Se eliminan los puntos redundantes en $L_{out}$. Para ello se tendrá que \\
		\quad \quad \quad \quad \ \ recorrer la lista y para cada punto $x \in L_{out}$,\\
		\quad \quad \quad \quad \ \ si $\forall y \in N(x); \phi(y) > 0$, se borra $x$ de $L_{out}$ y se cambia $\phi(x) = 3$. \\
		\quad \quad \quad \quad - Se comprueba la condición de parada y si se satisface se continua al paso 3, \\ 
		\quad \quad \quad \quad \ \ si no, seguiremos en el paso 2. \\
		\tabitem Paso 3: Segundo ciclo donde se realiza un suavizado del contorno con un \\ 
		\quad \quad \quad \quad \ \ filtro Gaussiano. \\
		\quad \quad \quad \quad - Evolución hacia fuera. Recorremos la lista $L_{out}$ y se calcula G $\oplus \ \phi(X)$. \\ 
		\quad \quad \quad \quad \ \ Si  G $\oplus \phi(X) <$ 0 se realiza la operación \textit{switch\_in(x)} \\ 
		\quad \quad \quad \quad - Se eliminan los puntos redundantes en $L_{in}$ (véase la figura \ref{switchLevelSet}).\\ 
		\quad \quad \quad \quad \ \ Para ello se tendrá que recorrer la lista y para cada punto $x \in L_{in}$,\\
		\quad \quad \quad \quad \ \ si $\forall y \in N(x); \phi(y) < 0$, se borra $x$ de $L_{in}$ y se cambia $\phi(x) = -3$. \\ 
		\quad \quad \quad \quad - Evolución hacia dentro. Recorremos la lista $L_{in}$ y se calcula  G $\oplus \ \phi(X)$. \\ 
		\quad \quad \quad \quad \ \ Si G $\oplus \phi(X)$ > 0 se realiza la operación \textit{switch\_out(x)}  \\ 
		\quad \quad \quad \quad - Se eliminan los puntos redundantes en $L_{out}$. Para ello se tendrá que \\
		\quad \quad \quad \quad \ \ recorrer la lista y para cada punto $x \in L_{out}$,\\
		\quad \quad \quad \quad \ \ si $\forall y \in N(x); \phi(y) > 0$, se borra $x$ de $L_{out}$ y se cambia $\phi(x) = 3$. \\
		\tabitem Paso 4:  Si se satisface la condición de parada del ciclo uno, se termina el algoritmo, \\
		\quad \quad \quad \quad \ \ si no, se vuelve al paso 2. \\
		\hline
	\end{tabular}
	\caption{Algoritmo completo de la aproximación del \textit{level set}}
	\vspace{2 mm}		
	Fuente: \cite{yong1}
	\label{algoritmoFastLevelSet}
\end{table}


Aclaradas las cuestiones anteriores, el (rápido) algoritmo \textit{level set} \cite{yong1} se muestra en la tabla \ref{algoritmoFastLevelSet}. Como se puede observar el segundo ciclo es prácticamente igual al primer ciclo, a excepción de que la condición de cambiar un punto de una lista a otra, es decir, de hacer una de las operaciones \textit{switch()} que se han explicado anteriormente, depende de un filtro Gaussiano (G) en el segundo ciclo (velocidad $F_{int}$) y de los datos en el primer ciclo (velocidad $F_{ext}$). Las operaciones de \textit{switch\_in()} se realizarán cuando el valor de $F$ ($F_{ext}$ en el primer ciclo y $F_{int}$ en el segundo ciclo) sea positivo, que querrá decir que el contorno deberá expandirse hacia fuera y las operaciones de \textit{switch\_out()} se realizarán cuando el valor de $F$ ($F_{ext}$ en el primer ciclo y $F_{int}$ en el segundo ciclo) sea negativo, contrayendo el contorno en ese punto. Véase la figura \ref{switchLevelSet} como ejemplo de expansión del contorno en un píxel.

Repasando un poco más el algoritmo \ref{algoritmoFastLevelSet} queda por aclarar las condiciones de parada del algoritmo. Así pues, el algoritmo se parará en el caso de que se cumpla una de estas dos condiciones:

\begin{enumerate}
	\item Que la velocidad $F_{ext}$ de toda la vecindad del contorno cumpla con:
	\begin{enumerate}	
		\item $F(x) \leq 0 \ \forall x \in L_{out}$, es decir, que no se tenga que expandir el contorno por ninguno de sus puntos.
		\item $F(x) \geq 0 \ \forall x \in L_{in}$, es decir, que no se tenga que contraer el contorno en ninguno de sus puntos.
	\end{enumerate}
	\item Que se alcance un determinado número de iteraciones establecido.
\end{enumerate}
 
Para finalizar, el coste del algoritmo es de orden O(2A($P_1$ + $P_2$)), donde A es el número de puntos entre el primer contorno creado y el último ya evolucionado, $P_1$ y $P_2$ el coste de las operaciones de switch() y el coste que tiene el borrado y la inserción de los puntos en las listas respectivamente. El escalar 2 es debido a que los puntos pueden llegar a pertenecer a una lista primero, y luego a otra, realizando así las operaciones dos veces. Nótese que ese A será mucho menor que la $m \times n$ que sería la anchura (m) por la altura (n) de la imagen, ya que si en la imagen se detectan varios objetos, el tamaño en puntos o píxeles de cada objeto se restará a ese $m \times n$.
   
 \begin{figure}[]
 	\captionsetup{justification=centering}
 	\centering
 	\includegraphics[width=.8\textwidth]{./imagenes/switchLevelSet}
 	\caption{Ejemplo de expansión del contorno un píxel hacía fuera. Operaciones que se realizan continuamente en el paso 2 y 3 del algoritmo}
	\vspace{2 mm}		
 	Fuente: modificaciones de imágenes en \cite{yong1}	
 	\label{switchLevelSet}
 \end{figure}
 
 
 
\section{Evolución del contorno}

Se ha querido añadir esta sección para destacar y hablar un poco más en detalle sobre la evolución de la curva que se ha elegido en esta aproximación: la presentada en \cite{chan}. Este popular trabajo es conocido como \textit{Chan-Vese model} y a diferencia de como se realizaba la segmentación, utilizando el uso de detectores de bordes basados en el gradiente, este trabajo realiza la detección de objetos cuyos bordes no tienen porque estar definidos por el gradiente. Este método es flexible y potente, capaz de realizar la segmentación de muchos tipos de imágenes que con métodos tradicionales como \textit{thresholding} o métodos basados en el gradiente no podían realizarse. Este método también permite que el contorno se inicialice dentro del objeto o incluso entre el objeto y el fondo ya que el resultado final será siempre el mismo. La figura \ref{chanVese} muestra las posibles inicializaciones. Esta característica será de utilidad como se comentará en posteriores capítulos.

Para tener una mínima idea del avance que esto supuso en la segmentación de imágenes, si volvemos a utilizar el buscador \cite{ieee1} y encontramos dicho artículo, el número de citaciones de otros artículos registrados en ese explorador alcanza casi la cifra de 2.000, lo que tampoco quiere decir que no haya más trabajos no registrados en \cite{ieee1} que lo citen. 
 
\begin{figure}[H]
	\captionsetup{justification=centering}	
	\begin{center}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.5\textwidth]{./imagenes/chanVese1}
			\subcaption{}\label{chanVese1}
		\end{subfigure}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.5\textwidth]{./imagenes/chanVese2}	
			\subcaption{}\label{chanVese2}
		\end{subfigure}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.5\textwidth]{./imagenes/chanVese3}	
			\subcaption{}\label{chanVese3}
		\end{subfigure}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.5\textwidth]{./imagenes/chanVese4}	
			\subcaption{}\label{chanVese4}
		\end{subfigure}
	\end{center}
	\caption{Posibles inicializaciones del contorno con el método de Chan-Vese}
	\vspace{2 mm}	
	\centering	
 	Fuente: \cite{chan}	
	\label{chanVese}
\end{figure} 
 
 
 
 
 
 
\chapter{Implementación de la aproximación y Ofeli}

Una vez encontrada una técnica que contemplara los requisitos del proyecto, se empezó a buscar alguna implementación sobre esta técnica. En esa búsqueda se encontró un trabajo llamado Ofeli (\textit{Open, Fast and Efficient Level set Implementation}) \cite{ofeli}. Este trabajo está desarrollado con Qt que es una de librerías multiplataforma para la realización de aplicaciones con GUI (\textit{graphical user interface}) en C++. Esta aplicación es muy completa ya que, aparte del algoritmo de interés, implementa varias funcionalidades extra como varios tipos de filtrado, preprocesamiento, varios tipos de evolución del contorno, etc.

\section{Ofeli}

En esta sección se explicará la estructura de la implementación y las clases que se utilizan en este trabajo. Se realizará un esquema general para que el lector pueda comprender cuáles son los procesos o pautas que se dan en esta implementación para poder segmentar una imagen.


\subsection{Estructura}

La implementación está formada por varias clases que se han dividido en dos tipos: las clases o ficheros que pertenecen a la GUI (etiquetadas con la palabra <<GUI->> por delante de sus nombres) y las clases que pertenecen a la implementación del algoritmo (etiquetadas con la palabra <<Impl->>).

\begin{enumerate}
	\item Impl-\textbf{ActiveContour}: clase padre de todos los tipos de contornos. Formada por lo ficheros:
		\begin{enumerate}
			\item activecontour.cpp
			\item activecontour.hpp
		\end{enumerate}
	\item Impl-\textbf{ACwithoutEdges}: clase que implementa el contorno que evolucionará en una imagen a escala de grises. Formada por lo ficheros:
	\begin{enumerate}
		\item ac\_withoutedges.cpp
		\item ac\_withoutedges.hpp
	\end{enumerate}
	\item Impl-ACwithoutEdgesYUV: clase que implementa el contorno que evolucionará en una imagen a color. Formada por lo ficheros:
	\begin{enumerate}
		\item ac\_withoutedges\_yuv.cpp
		\item ac\_withoutedges\_yuv.hpp
	\end{enumerate}
	\item Impl-\textbf{list}: implementación de una lista ligada genérica. Formada por lo ficheros:
	\begin{enumerate}
		\item linked\_list.tpp
		\item linked\_list.hpp
	\end{enumerate}
	\item Impl-Filters: clase que implementa los filtros que se le pueden aplicar a la imagen antes de realizar la segmentación. Formada por lo ficheros:
	\begin{enumerate}
		\item filters.cpp
		\item filters.hpp
	\end{enumerate}
	\item Impl-GeodesicAC: clase que implementa un contorno geodésico. Formada por lo ficheros:
	\begin{enumerate}
		\item geodesic\_ac.cpp
		\item geodesic\_ac.hpp
	\end{enumerate}
	\item Impl-HausdorffDistance: clase que implementa la distancia de Hausdorff. Formada por lo ficheros:
	\begin{enumerate}
		\item hausdorff\_distance.cpp
		\item hausdorff\_distance.hpp
	\end{enumerate}
	\item GUI-ImageViewer: formada por los ficheros:
	\begin{enumerate}
		\item imageviewer.cpp
		\item imageviewer.hpp
	\end{enumerate}
	\item GUI-PixmapWidget: formada por los ficheros:
	\begin{enumerate}
		\item pixmapwidget.cpp
		\item pixmapwidget.hpp
	\end{enumerate}
\end{enumerate}
 
Se han resaltado las tres clases que interesarán: \textit{ActiveContour}, \textit{ACwithoutEdges} y \textit{list}. Las demás clases añaden funcionalidades extra que no son necesarias en este proyecto.
 
\subsection{Esquema general}

 \begin{figure}[H]
 	\captionsetup{justification=centering}
 	\centering
 	\includegraphics[width=1.3\textwidth]{./imagenes/esquemaOfeli}
 	\caption{Esquema de las funciones utilizadas en el trabajo de Ofeli para realizar el algoritmo \textit{level set }aproximado}	
 	\label{esquemaOfeli}
 \end{figure}

Como se puede observar la estructura del código es prácticamente igual al algoritmo de aproximación presentado en \ref{algoritmoFastLevelSet} exceptuando que en esta implementación la velocidad de cada punto se calcula a la hora de tratar éste, no se calculan todas las velocidades de todos los puntos a la vez como se sugiere en el algoritmo \ref{algoritmoFastLevelSet}. El cálculo de estas velocidades son las funciones  \textit{compute\_(internal/external)\_speed\_($Fd/F_{int}$)} que se pueden ver en el esquema \ref{esquemaOfeli}. Las funciones  \textit{update\_for\_means\_(in/out)(1/2)} que no están en el algoritmo de aproximación presentado en \ref{algoritmoFastLevelSet} se realizan para poder <<adaptar>> el contorno a la imagen de manera que éste pueda evolucionar independientemente de los niveles de gris que se estén utilizando en la imagen. Esto se refiere a que se va haciendo una media de las intensidades de los puntos pertenecientes a las listas que representan implícitamente el contorno, es decir, $L_{out}$ y $L_{in}$, de manera que el umbral con el que se va decidiendo la velocidad de cada punto va cambiando en función de los puntos que representan el contorno.

Las funciones definidas como \textit{clean()} son las limpiezas de las listas sobre puntos redundantes que pudiera haber que se nombra en el algoritmo \ref{algoritmoFastLevelSet}. Debe de quedar claro que estas funciones recorren las listas completamente al igual que la evolución de cada una de ellas.

Otra cuestión a comentar es la etiqueta <<virtual>> que tienen varias funciones en el esquema \ref{esquemaOfeli} que significa exactamente, que la función es virtual. Esta característica es importante a la hora de entender la jerarquía de las clases y con ello la estructura del trabajo Ofeli. Una función virtual en el lenguaje de programación C++ se utiliza en cuestiones de herencia y polimorfismo, de manera que clases hijas puedan redefinir funciones definidas como virtuales en la clase padre. Así pues, las funciones  \textit{compute\_external\_speed\_Fd} y \textit{update\_for\_means\_(in/out)(1/2)} están definidas con esta cláusula ya que dependen de los datos, en este caso de las imágenes, y hay varias clases para trabajar con ellas en este trabajo. Si son imágenes a color se utilizará la clase \textit{ACwithoutEdgesYUV}, mientras que si es una imagen a escala de grises se trabajará con la clase \textit{ACwithoutEdges}, como se ha explicado en el anterior apartado.

Comentadas estas cuestiones se deduce que todas las funciones presentadas en el esquema \ref{esquemaOfeli} están implementadas en \textit{ActiveContour}, la clase padre, exceptuando aquellas que tienen la etiqueta <<virtual>> que las implementarán las clases hijas \textit{ACwithoutEdges} y \textit{ACwithoutEdgesYUV} dependiendo de las características de la imagen.
 
Para finalizar, la implementación de la lista ligada se utiliza para representar las listas $L_{out}$ y $L_{in}$ con las que estaremos trabajando continuamente en los dos ciclos.
 
 
 
 
 
 
 
 

\chapter{Paralelización de la aproximación del algoritmo \textit{level set}}

Las clases a modificar sobre el trabajo de Ofeli \cite{ofeli} para poder realizar una implementación paralela son: \textit{ActiveContour}, \textit{ACwithoutEdges} y \textit{list}. De manera que se paralelizará el código para realizar la segmentación de imágenes a escala de grises, ya que en un principio el cliente sólo está interesado en este tipo de imágenes. Aún así, una vez realizada la segmentación para este tipo de imágenes sería muy sencillo poder aplicarlo a imágenes a color, ya que, como se ha visto en el capítulo anterior, la mayoría de las funciones son comunes a la clase \textit{ActiveContour}. 

La segmentación a resolver es en cierto modo <<poco>> costosa, ya que se realiza en unos cuantos segundos. Las máquinas disponibles para la realización de este proyecto son una máquina propia del cliente  para realizar pequeñas pruebas (4 \textit{cores}), la máquina propia del autor de esta memoria (2 \textit{cores}) y una máquina de la Facultad de Informática de la UPV/EHU (48 \textit{cores}). Por todo ello, se ha elegido realizar la paralelización mediante  OpenMP\cite{openmp} por lo que las pruebas se realizarán en máquinas con una arquitectura SMP. Además, esta elección puede suponer una ventaja a la hora de querer realizar la segmentación de las imágenes de un vídeo ya que se podría combinar con el estándar MPI como se explicará en la sección \ref{propuestaDeMejora}. Para aprovechar las mejores opciones que esta API(\textit{Application Programming Interface}) nos ofrece, es decir, para poder sacarle el máximo rendimiento posible al algoritmo, se ha consultado un tutorial de \textit{Livermore Computing Center}, uno de los centros computacionales de primera clase del mundo \cite{live1}.

\section{Planteamiento de la paralelización}

Para empezar, se ha tenido que determinar donde es necesaria la paralelización. Fijándonos un poco en el código de cada ciclo, ya sea el de evolución del contorno o el del suavizado \textit{Gaussiano}, tiene en total cuatro bucles o recorridos de las listas. Estos recorridos son los que tendremos que paralelizar ya que son los <<cuellos de botella>> de este algoritmo. Nótese que la cantidad de puntos que contienen las listas puede ser muy grande a medida que se aumenta el tamaño de la imagen. Además, se deberán de hacer cuatro recorridos únicamente para expandir el contorno un píxel hacia fuera o hacia dentro. 

Una vez aclarada esta cuestión se debe observar más detalladamente cada recorrido de las listas en busca de condiciones de carrera. Así pues, se desglosan los cuatro recorridos comunes a los dos ciclos por separado:

\begin{enumerate}
	\item \textbf{Primer bucle}: recorrido de la lista $L_{out}$. La operación que se lleva a cabo en este bucle es la denominada \textit{switch\_in()} y se realiza/ejecuta solo si se cumple cierta condición dependiente únicamente de la velocidad del punto. Como recuerdo, esta operación trasladaba el punto tratado, perteneciente a la lista $L_{out}$, a la lista $L_{in}$ (al comienzo de la lista) y añadía la nueva vecindad de este punto a $L_{out}$ (también al comienzo de la lista).
	\begin{enumerate}
		\item Problema:	
			\begin{enumerate}
				\item Cuando dos \textit{threads} quieran cambiar el punto que están tratando de la lista $L_{out}$ a la lista $L_{in}$, al estar trabajando con listas ligadas, el querer añadir al mismo tiempo dos puntos al comienzo de la lista daría un problema con los punteros. Por lo tanto, esta operación de cambiar de lista un punto deberá de hacer atómicamente. 
				\item Al haber cambiado un punto de una lista a otra, en nuestro caso de $L_{out}$ a $L_{in}$ se añade la nueva vecindad de ese punto a $L_{out}$. Pasa exactamente lo mismo que en el anterior caso, cuando varios \textit{threads} están añadiendo puntos vecinos al principio de la lista habrá un problema con los punteros. 
				\item Otro problema relacionado con el anterior puede suceder cuando dos puntos de diferentes \textit{threads} quieran añadir al mismo vecino al mismo tiempo. Esto puede suceder dependiendo de la morfología de las islas de la imagen. Véase la figura \ref{mismoVecino} donde se supone que los puntos de la parte superior los procesa el primer \textit{thread} y los de la parte inferior el segundo \textit{thread}. En este ejemplo el punto A sería un vecino común para el punto directamente superior a él tratado por el primer \textit{thread} y para el punto directamente inferior a él, tratado por el segundo \textit{thread}. Si esto ocurriese, podría haber puntos repetidos en la lista, poniendo en riesgo su consistencia. 
			\end{enumerate}
		\item Solución:
			\begin{enumerate}
				\item La solución más sencilla para resolver los dos primeros problemas sería poner secciones críticas a la hora de añadir puntos a las listas. Obviamente esto resuelve el problema pero el rendimiento sería prácticamente el de la ejecución en serie si no es incluso peor que éste por el \textit{overhead} que pueda suponer la gestión de la sección crítica. Entonces, si el problema son las operaciones con las listas, está claro que cada \textit{thread} tendrá que tener una estructura propia donde añadir esos puntos para poder evitar estos dos primeros problemas. Así pues, se ha decidido <<partir>> las listas $L_{out}$ y $L_{in}$ en función del numero de \textit{threads}, para que cada uno trabaje con sus listas. Al final del ciclo habrá que volver a unir todos los <<trozos>> que tenga cada \textit{thread} para volver a reconstruir las listas. Estas operaciones pueden suponer un sobrecoste alto en cuanto a la versión serie, aún así, valiéndonos de las posibilidades que nos ofrecen las listas enlazadas podemos llegar a hacer estas dos operaciones casi en tiempo constantes. En el caso de no poder hacerlas eficientemente se podrían realizar cada cierto número de ciclos, aunque esto tendrá como consecuencia que la carga esté desbalanceada entre distintos \textit{threads}, ya que cada uno puede quitar o añadir una diferente cantidad de píxeles. Habrá que buscar un equilibrio para poder hacer un buen \textit{load balancing}. 
				\item En cuanto al tercer problema, no queda más opción que resolverlo mediante una sección crítica, en la que se asegure la inserción única del vecino. 
			\end{enumerate}
	\end{enumerate}
	\item \textbf{Segundo bucle}: limpieza de la lista $L_{in}$. En este recorrido se comprueba si hay algún punto redundante en base a su vecindad y si alguno lo es se quita de la lista. 
	\begin{enumerate}
		\item Problema:
			\begin{enumerate}
				\item Al realizar el borrado de un punto de la lista, y al trabajar con listas enlazadas, puede que otro \textit{thread} este tratando el elemento posterior al que se vaya a eliminar y se tenga problema con los punteros de nuevo. Hay que decir también que esta situación solo se podrá dar con los puntos <<frontera>>, es decir, con el último punto de un \textit{thread} y el primero de otro.
			\end{enumerate}
		\item Solución: 
			\begin{enumerate}
				\item Este problema quedaría resuelto con la solución propuesta para los primeros problemas del primer bucle, es decir, el troceado de las listas en base al número de \textit{thread}: un trozo por cada uno de ellos.
			\end{enumerate}
	\end{enumerate}
	\item \textbf{Tercer bucle}: recorrido de $L_{in}$. Los problemas y soluciones de este bucle son exactamente iguales a los del primero ya que son simétricos, es decir, que en este caso las operaciones serán las inversas. El cambio de un punto que cumple con la condición de velocidad esta vez será de $L_{in}$ a $L_{out}$ y se añadirán los puntos de éste a $L_{in}$. 
	\item \textbf{Cuarto bucle}: limpieza de $L_{out}$. De la misma manera que el tercer bucle los problemas y soluciones del segundo bucle serán válidos para éste también al ser el caso contrario, la limpieza de $L_{out}$.
\end{enumerate}

 \begin{figure}[H]
 	\captionsetup{justification=centering}
 	\centering
 	\includegraphics[width=0.6\textwidth]{./imagenes/mismoVecino}
 	\caption{Ejemplo de condición de carrera al querer añadir un punto vecino en común a puntos tratados por distintos \textit{threads}}	
 	\label{mismoVecino}
 \end{figure}

\subsection{Primera implementación}

En esta sección se explican las características de la primera implementación paralela realizada siguiendo el análisis del anterior apartado. Así pues, cada ciclo quedará estructurado como se ve en la figura \ref{1-Imple}. Las nuevas características son de color rojo y se han marcado con un asterisco(*). 

 \begin{figure}[H]
 	\captionsetup{justification=centering}
 	\centering
 	\includegraphics[width=1.2\textwidth]{./imagenes/1-Imple}
 	\caption{Esquema de la primera implementación}	
 	\label{1-Imple}
 \end{figure}

En esta primera implementación se invirtió mucho tiempo ya que los cambios realizados fueron muchos. Se irá paso a paso comentando las características de cada cambio, así como la razón por la que se llevo a cabo dicho cambio.

\subsubsection{Lista enlazada}

Muchos han sido los cambios realizados en comparación con la implementación de lista enlazada creada en el trabajo Ofeli. Todos los cambios aquí realizados han tenido como objetivo minimizar el coste operacional de las operaciones necesarias para realizar la paralelización. 

\begin{enumerate}
	\item Se ha insertado en cada nodo un puntero hacia el elemento anterior, es decir, se ha creado una lista doblemente ligada. 
	\item La modificación anterior ha dado pie a crear un apuntador al final de la lista, un \textit{tail}.
	\item Se ha convertido el tiempo de la ejecución de la función size() en orden constante en lugar de la implementación computacionalmente lineal (al número de elementos de la lista) que estaba.
	\item Otras modificaciones que no influyen en la implementación paralela.
\end{enumerate}

\subsubsection{División de la lista}

Las listas $L_{out}$ y $L_{in}$ se dividen en un número de trozos o sublistas igual al número de \textit{threads} de manera que cada uno tenga la parte de la lista original con la que trabajará. 

Al inicio del programa, después de inicializar las dos listas con el contorno definido manualmente, se crean tantos punteros o apuntadores como \textit{threads} vayan a trabajar en la ejecución. Cada puntero se coloca apuntando al primer elemento que tratará cada \textit{thread}, es decir, suponiendo que tenemos 80 elementos a repartir entre cuatro \textit{threads}, el primer puntero apuntará al primer elemento, ya que será el primer elemento a tratar por el primer \textit{thread}, el segundo puntero apuntará al vigésimo primer elemento y así sucesivamente. Véase la figura \ref{divisionLista1} para ver un ejemplo de ello. Esta primera recolocación de los \textit{heads} de cada \textit{thread} se realiza en tiempo lineal al número de elementos en las listas, sin embargo, esta operación sólo se realiza en la preparación de la evolución y por lo tanto, una sola vez. 

 \begin{figure}[H]
 	\captionsetup{justification=centering}
 	\centering
 	\includegraphics[width=1\textwidth]{./imagenes/divisionLista1}
 	\caption{Esquema de la colocación de los \textit{heads} de trozo de lista a crear}	
 	\label{divisionLista1}
 \end{figure}
 
 
Por lo tanto, se accede en un orden constante a cada elemento \textit{head} creado, se establecen los \textit{tails} de las sublistas accediendo al anterior elemento de estos \textit{heads}, se establecen los tamaños de cada sublista (posible conociendo la posición de cada \textit{tail} y llevando una cuenta) y se <<rompen>> los enlaces con sus anteriores elementos de manera que se separen por completo las sublistas. Todo ello es posible gracias a las modificaciones realizadas en la implementación de la lista ligada. Véase la figura \ref{divisionLista2} para ver un ejemplo de todo ello. 

 \begin{figure}[H]
 	\captionsetup{justification=centering}
 	\centering
 	\includegraphics[width=1\textwidth]{./imagenes/divisionLista2}
 	\caption{Ejemplo de creación de cada sublista usando los \textit{heads} establecidos}	
 	\label{divisionLista2}
 \end{figure} 
 
 
\subsubsection{Unión de las sublistas} 

Siguiendo el procedimiento inverso a la división de las listas se realiza la unión. En este caso, sabiendo los \textit{heads} y los \textit{tails} de cada sublista, se vuelve a crear la unión entre ellas, más concretamente, entre el \textit{tail} y el \textit{head} de la siguiente lista. El tamaño de la lista completa será la suma de los tamaños de todas las sublistas. Véase la figura \ref{unionLista1} como explicación de ello.

 \begin{figure}[H]
 	\captionsetup{justification=centering}
 	\centering
 	\includegraphics[width=1\textwidth]{./imagenes/unionLista1}
 	\caption{Ejemplo de unión de cada sublista usando los \textit{heads} y \textit{tails} de cada una}	
 	\label{unionLista1}
 \end{figure} 
 
Al realizar esta unión, también se aprovecha a reinicializar los \textit{heads} que se utilizarán en la siguiente división de la lista. Los \textit{heads} se inicializarán previamente como los \textit{heads} de cada sublista. Nótese que estos \textit{heads} se habrán posicionado muy cerca de la posición óptima, ya que habitualmente todas las zonas del contorno tienden a expandirse por igual. No obstante, se realiza un centrado de cada \textit{head}, es decir, se mueve el puntero hasta la posición exacta en la que debe estar, si es que no lo está, realizando la división del número de puntos entre el número de \textit{thread} de la ejecución. Los \textit{tails} no harán falta establecerlos ya que se posicionan en la división de las listas. Véase la figura \ref{unionLista2} como explicación de ello. El número de operaciones a realizar comparadas con el número de puntos en la lista es pequeño.

 \begin{figure}[H]
 	\captionsetup{justification=centering}
 	\centering
 	\includegraphics[width=1\textwidth]{./imagenes/unionLista2}
 	\caption{Ejemplo de unión de cada sublista usando los \textit{heads} y \textit{tails} de cada una}	
 	\label{unionLista2}
 \end{figure}
 
 
 
 \subsubsection{Secciones críticas} 
 
 Las secciones críticas a realizar para resolver la condición de carrera se han establecido en las funciones de añadir un vecino del punto que se cambia de una lista a otra. Se ha seguido un esquema \textit{Test and Test-and-set} para minimizar la contención de la sección crítica ya que se realiza antes la condición que se debe de hacer en la sección crítica antes de entrar a ésta.
 
 A continuación se presenta el código de la sección crítica.


\subsubsection{Código}

\begin{lstlisting}
void ActiveContour::add_Rout_neighbor_to_Lout(int neighbor_offset,int tid)
{
	//Test, test and set
	if( phi[neighbor_offset] == 3 ) // exterior value
	{
		#pragma omp critical
		{
			if( phi[neighbor_offset] == 3 ) // exterior value
			{
				phi[neighbor_offset] = 1; // outside boundary value
	
				Splited_Lout[tid]->push_front(neighbor_offset);	
			}
		}
	}	
return;}

void ActiveContour::add_Rin_neighbor_to_Lin(int neighbor_offset,int tid)
{
	//Test, test and set
	if( phi[neighbor_offset] == -3 ) // interior value
	{
		#pragma omp critical
		{
			if( phi[neighbor_offset] == -3 ) // interior value
			{
				phi[neighbor_offset] = -1; // inside boundary value
			
				Splited_Lin[tid]->push_front(neighbor_offset);
			}
		}
	}	
return;}	
\end{lstlisting}

 
\subsection{Rendimiento}
 
Realizada la primera implementación, llega la hora de comprobar su rendimiento y ver la mejora obtenida respecto a la versión serie. En estas primeras pruebas se ha utilizado únicamente una imagen de tamaño 3000x2800 y que es exactamente la que se muestra en la figura \ref{ejemplo4}.

Las pruebas realizadas han sido en un ordenador de la Universidad del País Vasco. Este ordenador tiene una arquitectura SMP, con una memoria principal de 64GB y dispone de cuatro procesadores \textit{AMD Opteron(tm) Processor 6168} los cuales tienen doce \textit{cores} que trabajan a 1900 MHz. Por lo tanto, se disponen de 48 \textit{cores} para poder realizar las pruebas. También se ha considerado añadir que se ha tenido que separar la parte gráfica del trabajo original de Ofeli y extraer el algoritmo de evolución para poder realizar las pruebas. 

La compilación se ha realizado con el compilador gcc (versión 4.6.3) con la siguiente línea de comandos:

\

\quad \quad \textbf{g++ main.cpp activecontour.cpp ac\_withoutedges.cpp -o prueba}

\quad \quad	\textbf{-O3 -fopenmp -Dcimg\_use\_png -lpng -lz -Dcimg\_display=0}

\

Mientras no se diga lo contrario, todas las ejecuciones se realizarán en la misma máquina y los tiempos de todas las tablas que aparezcan serán la media de cinco ejecuciones. A esta primera implementación se le nombrará como <<sección critica normal>>.


\begin{table}[h]
	\small
	\centering
	\captionsetup{justification=centering}
	\begin{tabular}{cccccccc}
		\hline
		\multicolumn{1}{|c|}{{\bf Número de threads}} & \multicolumn{1}{c|}{{\bf Serie}} & \multicolumn{1}{c|}{{\bf 2}} & \multicolumn{1}{c|}{{\bf 4}} & \multicolumn{1}{c|}{{\bf 8}} & \multicolumn{1}{c|}{{\bf 16}} & \multicolumn{1}{c|}{{\bf 32}} & \multicolumn{1}{c|}{{\bf 48}} \\ \hline
		\multicolumn{1}{|c|}{{\bf Tiempo (s)}}           & \multicolumn{1}{c|}{16,52}      & \multicolumn{1}{c|}{11,63}  & \multicolumn{1}{c|}{7,80}   & \multicolumn{1}{c|}{9,38}   & \multicolumn{1}{c|}{14,37}   & \multicolumn{1}{c|}{27,66}   & \multicolumn{1}{c|}{31,37}   \\ \hline
		\multicolumn{1}{l}{}                         & \multicolumn{1}{l}{}             & \multicolumn{1}{l}{}         & \multicolumn{1}{l}{}         & \multicolumn{1}{l}{}         & \multicolumn{1}{l}{}          & \multicolumn{1}{l}{}          & \multicolumn{1}{l}{}          \\ \hline
		\multicolumn{1}{|c|}{{\bf Speed-up}}         & \multicolumn{1}{c|}{1,00}        & \multicolumn{1}{c|}{1,42}    & \multicolumn{1}{c|}{2,12}    & \multicolumn{1}{c|}{1,76}    & \multicolumn{1}{c|}{1,15}     & \multicolumn{1}{c|}{0,60}     & \multicolumn{1}{c|}{0,53}     \\ \hline
		{\bf }                                       &                                  &                              &                              &                              &                               &                               &                               \\ \hline
		\multicolumn{1}{|c|}{{\bf Eficiencia}}       & \multicolumn{1}{c|}{100,00\%}    & \multicolumn{1}{c|}{71,03\%} & \multicolumn{1}{c|}{52,98\%} & \multicolumn{1}{c|}{22,02\%} & \multicolumn{1}{c|}{7,19\%}   & \multicolumn{1}{c|}{1,87\%}   & \multicolumn{1}{c|}{1,10\%}   \\ \hline
	\end{tabular}
	\caption{Rendimiento de las ejecuciones de la primera implementación paralela}
\end{table}	


\begin{figure}[H]
 	\captionsetup{justification=centering}
 	\centering
 	\includegraphics[width=.7\textwidth]{./imagenes/grafico1Imple}
 	\caption{Gráfica de los tiempos de ejecución de la primera implementación paralela}	
 	\label{grafico1Imple}
\end{figure}

Como se puede observar en la figura \ref{grafico1Imple}, esta primera implementación sólo escala bien hasta los cuatro \textit{cores}. 

\subsubsection{Conclusión}

Se analizan los tiempos de ejecución y se comprueba que, efectivamente, el cuello de botella está en el acceso a la sección crítica. Véase el desglose del tiempo de ejecución (2 \textit{cores}) de un ciclo en la tabla \ref{tablaConclusiones1}. Aquí se puede observar que la mayoría del tiempo se pierde en realizar los bucles 1 y 2, es decir, donde están las funciones con la secciones críticas. Esto sucede ya que ésta se hace prácticamente siempre, debido a que el contorno suele tender a expandirse, y puede que se repita varias veces por cada punto, al realizarse por cada nuevo vecino. Por otro lado, la ejecución es únicamente con dos \textit{cores}, por lo que la contención de la sección crítica será mayor con más \textit{cores}, razón por la que esta primera implementación no escala bien.

\begin{table}[H]
	\centering
	\small
	\captionsetup{justification=centering}
	\begin{tabular}{c|c|c|c|c|c|c|c}
		\cline{2-8}
		\multicolumn{1}{l|}{}                          & {\bf \begin{tabular}[c]{@{}c@{}}División\\   listas\end{tabular}} & {\bf  \begin{tabular}[c]{@{}c@{}}1º\\   bucle\end{tabular}} & {\bf \begin{tabular}[c]{@{}c@{}}Clean\\   Lin\end{tabular}} & {\bf  \begin{tabular}[c]{@{}c@{}}2º\\   bucle\end{tabular}} & {\bf \begin{tabular}[c]{@{}c@{}}Clean\\   Lout\end{tabular}} & {\bf \begin{tabular}[c]{@{}c@{}}Unión\\   listas\end{tabular}} & \multicolumn{1}{c|}{{\bf \begin{tabular}[c]{@{}c@{}}POR\\   CICLO\end{tabular}}} \\ \hline
		\multicolumn{1}{|c|}{{\bf Serie}}              & 0,0                  & 0,0127       & 0,008         & 0,0145       & 0,0071         & 0,0                                                               & \multicolumn{1}{c|}{0,043}         \\ \hline
		\multicolumn{1}{|c|}{{\bf \begin{tabular}[c]{@{}c@{}}Óptimo 2\\   threads\end{tabular}}}   & 0,0                  & 0,0063       & 0,0040        & 0,0072       & 0,0035         & 0,0                                                              & \multicolumn{1}{c|}{0,0215}        \\ \hline
		\multicolumn{1}{|c|}{{\bf \begin{tabular}[c]{@{}c@{}}Paralelo 2\\   threads\end{tabular}}} & 0,0                  & 0,0093       & 0,0041        & 0,0109       & 0,0038         & 0,0                                                               & \multicolumn{1}{c|}{0,0281}        \\ \hline
		\multicolumn{1}{|c|}{{\bf Sobrecoste}}           & 0,0\%                    & 46,0\%         & 2,1\%           & 51,3\%         & 8,6\%            & 0,0\%                                                                 & \multicolumn{1}{l}{}                 \\ \cline{1-7}
	\end{tabular}
	\caption{Desglose de tiempos (s) de un ciclo del algoritmo con una ejecución paralela con dos \textit{cores} de la primera implementación}		
	\label{tablaConclusiones1}
\end{table}


\section{Primer paso de mejora: segunda implementación}

Concluido ya que el problema está en la sección crítica se intenta reducir las operaciones dentro de ésta reduciendo así el tiempo que cada \textit{thread} está dentro de ella. La <<sección crítica mejorada>> tendrá únicamente dos asignaciones, reduciendo considerablemente el tiempo dentro de ella. Se utilizará un \textit{flag} para saber qué \textit{thread} ha sido el que ha entrado a la sección crítica para posteriormente hacer la operación correspondiente. En este caso obviaremos la segunda función ya que tiene las mismas características que la primera.

\subsubsection{Código}

\begin{lstlisting}

 void ActiveContour::add_Rout_neighbor_to_Lout(int neighbor_offset,int tid)
 {
 	bool flag = false;
 	
 	if( phi[neighbor_offset] == 3 ) // exterior value
 	{
 		#pragma omp critical
 		{
 			if( phi[neighbor_offset] == 3 ) // exterior value
 			{
 				phi[neighbor_offset] = 1; // outside boundary value
 				flag = true;
 			}
 		}
 		if(flag)  Splited_Lout[tid]->push_front(neighbor_offset);
 	} 	
 	return; 
 }
 	
\end{lstlisting}

\subsection{Rendimiento}

\begin{table}[H]
	\small
	\centering
	\captionsetup{justification=centering}
	\begin{tabular}{cccccccc}
		\hline
		\multicolumn{1}{|c|}{{\bf Núm. \textit{threads}}} & \multicolumn{1}{c|}{{\bf Serie}} & \multicolumn{1}{c|}{{\bf 2}} & \multicolumn{1}{c|}{{\bf 4}} & \multicolumn{1}{c|}{{\bf 8}} & \multicolumn{1}{c|}{{\bf 16}} & \multicolumn{1}{c|}{{\bf 32}} & \multicolumn{1}{c|}{{\bf 48}} \\ \hline
		\multicolumn{1}{|c|}{{\bf Tiempo (s)}}           & \multicolumn{1}{c|}{16,52}      & \multicolumn{1}{c|}{10,74}  & \multicolumn{1}{c|}{6,58}   & \multicolumn{1}{c|}{5,42}   & \multicolumn{1}{c|}{3,68}    & \multicolumn{1}{c|}{6,02}    & \multicolumn{1}{c|}{6,79}    \\ \hline
		\multicolumn{1}{l}{}                         & \multicolumn{1}{l}{}             & \multicolumn{1}{l}{}         & \multicolumn{1}{l}{}         & \multicolumn{1}{l}{}         & \multicolumn{1}{l}{}          & \multicolumn{1}{l}{}          & \multicolumn{1}{l}{}          \\ \hline
		\multicolumn{1}{|c|}{{\bf Speed-up}}         & \multicolumn{1}{c|}{1,00}        & \multicolumn{1}{c|}{1,54}    & \multicolumn{1}{c|}{2,51}    & \multicolumn{1}{c|}{3,05}    & \multicolumn{1}{c|}{4,49}     & \multicolumn{1}{c|}{2,74}     & \multicolumn{1}{c|}{2,43}     \\ \hline
		{\bf }                                       &                                  &                              &                              &                              &                               &                               &                               \\ \hline
		\multicolumn{1}{|c|}{{\bf Eficiencia}}       & \multicolumn{1}{c|}{100,0\%}    & \multicolumn{1}{c|}{76,9\%} & \multicolumn{1}{c|}{62,8\%} & \multicolumn{1}{c|}{38,1\%} & \multicolumn{1}{c|}{28,1\%}  & \multicolumn{1}{c|}{8,6\%}   & \multicolumn{1}{c|}{5,1\%}   \\ \hline
	\end{tabular}
	\caption{Rendimiento obtenido de las ejecuciones de la segunda implementación paralela}
\end{table}




\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.8\textwidth]{./imagenes/grafico2Imple}
	\caption{Gráfica de los tiempos de ejecución de la primera y segunda implementación}	
	\label{grafico2Imple}
\end{figure}

Como se puede ver en el gráfico \ref{grafico2Imple} la mejora es bastante notable. Esto se debe a que se ha reducido notablemente la contención entre los \textit{threads} al no tener prácticamente operaciones a realizar dentro de la sección crítica. El tiempo de ejecución del sistema se reduce hasta los 16 cores.

\


\subsubsection{Conclusión}

A pesar de haber mejorado mucho los tiempos el resultado no sigue siendo óptimo del todo ya que la implementación escala poco a poco hasta los 16 \textit{threads} y luego el tiempo va aumentado. Hay que intentar reducir aún más la contención de alguna manera. Analizando un poco más a detalle, la sección crítica se realiza para cualquier vecino que se quiera añadir después de haber expandido o contraído un punto. Es decir, que no importa la localización de los puntos que se estén tratando, habrá colisión en la sección crítica. En realidad, la sección crítica se puso para evitar que se pudieran añadir varios puntos vecinos a la vez. ¿Hay alguna manera de realizar secciones críticas dependientes del punto? Sería la pregunta clave a responder para poder resolver el problema. 

\section{Segundo paso de mejora: tercera implementación}

Buscando alguna manera de realizar secciones críticas dependiente del punto se deciden usar semáforos o \textit{locks} en inglés. Se podría tener una matriz de \textit{locks} de la misma dimensión que la imagen y cada vez que se vaya a trabajar con un punto cerrar el \textit{lock} que le pertenece. El problema de esta idea de tener un \textit{lock} para cada píxel, en una imagen de 3000x2800, sería la cantidad de memoria y la complejidad de gestión de éstos, ya que el número de \textit{locks} necesarios sería muy elevado. Como alternativa y buscando una solución de compromiso se ha implementado un esquema de \textit{locks} por zonas. En vez de tener un \textit{lock} para cada punto se podría tener un número de \textit{locks} no muy grande para bloquear cierta zona de la imagen. 

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.7\textwidth]{./imagenes/mallaLocks}
	\caption{Ejemplo de una malla de cuatro locks de establecidos en forma rectangular}	
	\label{mallaLocks}
\end{figure}

En la imagen \ref{mallaLocks} se puede observar un ejemplo de una malla de \textit{locks} en la número de \textit{locks} establecido es 4 y tiene una forma rectangular. El número de óptimo de locks a establecer será lo que se trabaje en esta tercera implementación. Además, el lector podría pensar que se pueden realizar distintas figuras geométricas en la creación de la estructura de \textit{locks}, aunque esta opción no se realizará en este proyecto ya que la estrategia de distribución de los puntos en las sublistas se realiza recorriendo la matriz por filas, lo que significa que los rectángulos darán una mejor respuesta temporal ya que habrá poca colisión entre los \textit{threads}.

\subsubsection{Código}

\begin{lstlisting}
void ActiveContour::add_Rout_neighbor_to_Lout(int neighbor_offset,int tid)
{
	bool flag = false;	
	
	if( phi[neighbor_offset] == 3 ) // exterior value
	{
		int lockNumber = ( (neighbor_offset/img_width) *numLocks)/img_height;
					
		omp_set_lock(&(locks[lockNumber]));	
					
		if( phi[neighbor_offset] == 3 ) // exterior value
		{
			phi[neighbor_offset] = 1; // outside boundary value
			flag = true;
		}	
		
		omp_unset_lock(&(locks[lockNumber]));	
		
		if(flag)  Splited_Lout[tid]->push_front(neighbor_offset);
	}
	return;	
}
\end{lstlisting}


\subsection{Rendimiento}


\begin{table}[H]
	\centering
	\captionsetup{justification=centering}
	\begin{tabular}{lc|c|c|c|c|c|c|lcccl}
		\cline{3-8}
		& \multicolumn{1}{l|}{} & \multicolumn{6}{c|}{{\bf Locks}}                              &                       & \multicolumn{1}{l}{}          & \multicolumn{1}{l}{}  & \multicolumn{1}{l}{}            &  \\ \cline{3-8} \cline{10-10} \cline{12-12}
		&                       & {\bf 4} & {\bf 8} & {\bf 16} & {\bf 24} & {\bf 32} & {\bf 50} & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{{\bf su}} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{{\bf Efi.}} &  \\ \cline{1-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{\multirow{13}{*}{{\bf \rotatebox[origin=c]{90}{THREADS}}}} & {\bf 1}               & 16,69   & 16,64   & 16,63    & 16,61    & 16,79    & 16,73    & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{-}        & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{-}          &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 2}               & 10,49   & 10,64   & 10,35    & 10,52    & 10,35    & 10,33    & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{1,59}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{79,6\%}     &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 4}               & 6,79    & 7,03    & 6,86     & 6,85     & 6,73     & 6,60     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{2,46}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{61,5\%}     &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 8}               & 4,22    & 5,73    & 5,72     & 5,42     & 5,44     & 5,40     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{3,96}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{49,5\%}     &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 12}               & 4,10    & 4,63    & 4,31     & 4,53     & 5,11     & 5,12     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{4,07}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{33,9\%}     &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 16}              & 3,99    & 3,93    & 4,89     & 3,26     & 4,87     & 4,84     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{4,18}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{26,1\%}     &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 20}              & 3,29    & 3,87    & 3,88     & 3,19     & 3,89     & 3,89     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{5,08}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{25,4\%}     &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 24}              & 2,95    & 3,28    & 3,29     & 3,32     & 3,30     & 3,29     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{5,65}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{23,5\%}     &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 28}              & 3,03    & 2,96    & 2,93     & 2,92     & 2,96     & 2,93     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{5,52}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{19,7\%}     &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 32}              & 2,85    & 2,72    & 2,80     & 2,70     & 3,00     & 2,80     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{5,86}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{18,3\%}     &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 36}              & 3,74    & 3,81    & 3,29     & 3,48     & 2,85     & 3,28     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{4,46}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{12,4\%}     &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 40}              & 4,12    & 4,06    & 3,79     & 3,98     & 3,85     & 3,81     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{4,05}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{10,1\%}     &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 44}              & 4,00    & 4,06    & 4,05     & 3,83     & 3,75     & 3,74     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{4,18}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{9,5\%}      &  \\ \cline{2-8} \cline{10-10} \cline{12-12}
		\multicolumn{1}{|l|}{}                                & {\bf 48}              & 3,91    & 3,91    & 3,77     & 3,68     & 3,82     & 3,66     & \multicolumn{1}{l|}{} & \multicolumn{1}{c|}{4,27}     & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{8,9\%}      &  \\ \cline{1-8} \cline{10-10} \cline{12-12}
	\end{tabular}
	\caption{Tiempos de ejecución (s),  eficiencia y \textit{speed-ups} (su) obtenidos con distintas combinaciones de \textit{threads} y \textit{locks} en la tercera implementación paralela}
\end{table}

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=0.8\textwidth]{./imagenes/grafico3Imple}
	\caption{Gráfico de los resultados obtenidos en este tercera implementación}
	\label{Implementacion3}
\end{figure}

Como se puede observar en la figura \ref{Implementacion3} se ha mejorado aún más la respuesta temporal, escala bien hasta los 32 \textit{threads} en vez de hasta los 16 que se conseguían con la anterior implementación (véase la figura \ref{grafico2Imple}). Las ejecuciones más rápidas se logran con la combinación de 32 \textit{threads} y con 24 \textit{locks}, teniendo un resultado de 2,7 segundos. 

Por otro lado, también se han realizado pruebas con la primera implementación, es decir, con la <<sección crítica normal>> para analizar el efecto de la reducción de la contención mediante la solución de \textit{locks} distribuidos en dicha implementación. Esto se refiere a que la sección la crearán los \textit{locks} pero lo que hay dentro será lo que había en la implementación de la <<sección crítica normal>>. Los resultados son los que se muestran en el gráfico \ref{grafico3-2Imple}. Como se puede observar el tiempo obtenido es prácticamente el conseguido con la última implementación realizada. Esto quiere decir que el problema de todo ello era la contención que había con todos los \textit{threads} y no importa tanto el tiempo que se pasa dentro de la sección crítica. Sin embargo, también ahí que decir que con la implementación de la <<sección crítica normal>> son necesarios más \textit{locks} para evitar esa contención entre los \textit{threads} ya que la sección crítica es más larga.

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.9\textwidth]{./imagenes/grafico3-2Imple}
	\caption{Gráfica de los tiempos de ejecución con los \textit{locks} y la estructura de la <<sección crítica normal>>}	
	\label{grafico3-2Imple}
\end{figure}


\subsubsection{Conclusión}

Ya que los resultados obtenidos con la última implementación y la primera son parecidos no se podrá reducir mucho más el tiempo en cuanto a la contención, ya que parece que a partir de cierto número de \textit{locks} ésta desaparece. Así pues, la reducción tendría que hacerse por otra vía, o bien intentar reducir el tiempo que se realiza en paralelo o entrar en más detalle como la compartición falsa en la memoria caché que pudiera haber con ciertas variables de la implementación. El propio tiempo de gestión de los \textit{locks}, la compartición falsa en caché que pudiera haber con ciertas variables, la gestión de la sección paralela y la división y unión de las listas parece que añaden en total un \textit{overhead} que se ha decidido dejar fuera del ámbito de este proyecto. 








\chapter{Experimentación}

En este capítulo mostraremos el rendimiento de la mejor versión implementada, la tercera versión, aquella con la <<sección critica mejorada>> y haciendo uso de la malla de \textit{locks} con más detalle. En las anteriores presentaciones de los rendimientos de las distintas implementaciones se ha utilizado un tipo concreto de imagen, con un tamaño determinado (3000x2800) y una inicialización específica del contorno. En este apartado realizaremos pruebas más completas, combinando distintos factores para ver más detalladamente el comportamiento de la mejor versión de la paralela. Además, se podrá llegar a concluir qué tipo de combinación beneficia a la evolución del contorno en cierto tipo de imágenes.

Se ha decidido probar 3 tipos de imágenes diferentes, con varios tamaños de éstas, varios tamaños de las mallas de \textit{locks} y varios \textit{threads}. En la figura \ref{tiposImagenes} se puede observar los tres tipos de imágenes diferentes que se utilizarán en la realización de dichas pruebas.


\begin{figure}[H]
	\centering	
	\captionsetup{justification=centering}	
	\begin{center}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.7\textwidth]{./imagenes/buena1}
			\subcaption{}\label{buena1}
		\end{subfigure}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.8\textwidth]{./imagenes/ejemplo2}	
			\subcaption{}\label{buena2}
		\end{subfigure}
		\begin{subfigure}[t]{2.5in}
			\centering
			\includegraphics[width=.8\textwidth]{./imagenes/buena3}	
			\subcaption{}\label{buena3}
		\end{subfigure}
	\end{center}
	\caption{Tipos de imágenes con las que se realizarán las pruebas completas de la tercera implementación}
	\label{tiposImagenes}
\end{figure} 


\section{Primera imagen}

La primera imagen a probar será la imagen \ref{buena1}, una imagen borrosa, con poca diferencia en tono de gris entre las islas y el fondo, y con una morfología de las islas alargada. A continuación se presentan los resultados de las ejecuciones con diferentes tamaños de la imagen. Se ha resaltado en negrita el mejor tiempo de ejecución y se ha marcado con un asterisco los valores más cercano al óptimo conseguido.

\subsubsection{500x500}

\begin{table}[H]
	\centering
	\small
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		{\bf \backslashbox{Threads}{Locks}}   & {\bf 4} & {\bf 8} & {\bf 16} & {\bf 24} & {\bf 32} & {\bf 50} \\ \hline
		{\bf 1}  & 2,01    & 2,03    & 2,03     & 2,04     & 2,04     & 2,03     \\ \hline
		{\bf 2}  & 1,34    & 1,37    & 1,37     & 1,34     & 1,35     & 1,35     \\ \hline
		{\bf 4}  & 1,00    & 0,96    & 0,96     & 0,97     & 0,96     & 0,95     \\ \hline
		{\bf 8}  & 0,62    & 0,91    & 0,91     & 0,80     & 0,88     & 0,90     \\ \hline
		{\bf 12} & 0,62    & 0,72    & 0,72     & 0,64     & 0,81     & 0,81     \\ \hline
		{\bf 16} & 0,62    & 0,56    & 0,56     & 0,48     & 0,74     & 0,70     \\ \hline
		{\bf 20} & 0,53    & 0,64    & 0,64     & 0,50     & 0,67     & 0,60     \\ \hline
		{\bf 24} & 0,43    & 0,52    & 0,52     & 0,56     & 0,56     & 0,49     \\ \hline
		{\bf 28} & 0,47    & 0,43    & 0,43     & 0,45     & 0,43     & 0,47     \\ \hline
		{\bf 32} & 0,42    & 0,40    & 0,40     & 0,39     & 0,38     & 0,39     \\ \hline
		{\bf 36} & 0,44    & 0,37    & 0,37     & 0,35     & 0,34     & 0,36     \\ \hline
		{\bf 40} & 0,44    & 0,32    & 0,32     & 0,31*     & 0,32     & 0,32     \\ \hline
		{\bf 44} & 0,45    & 0,35    & 0,35     & 0,31*     & 0,31*     & \textbf{0,30}     \\ \hline
		{\bf 48} & 0,45    & 0,36    & 0,36     & 0,33     & 0,34     & 0,37     \\ \hline
	\end{tabular}
	\captionsetup{justification=centering}	
	\caption{Tiempos de ejecución de la imagen \ref{buena1} con un tamaño de 500x500}
	\label{img1-500}	
\end{table}

Como se puede observar en la tabla \ref{img1-500} los mejores tiempos se consiguen con 40 y 44 \textit{threads} y a partir de los 24 \textit{locks}. El menor tiempo que se consigue es de 0,3 segundos, con un \textit{speed-up} de 6,7 y una eficiencia del 15,1\%.

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.7\textwidth]{./imagenes/graf1-500}
	\caption{Gráfica de los tiempos de ejecución de la imagen \ref{buena1} con un tamaño de 500x500}	
	\label{graf1-500}
\end{figure}

\subsubsection{1500x1500}


\begin{table}[H]
	\centering
	\small
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		{\bf \backslashbox{Threads}{Locks}}   & {\bf 4} & {\bf 8} & {\bf 16} & {\bf 24} & {\bf 32} & {\bf 50} \\ \hline
		{\bf 1}  & 14,88   & 14,91   & 14,92    & 14,87    & 14,92    & 14,90    \\ \hline
		{\bf 2}  & 8,52    & 8,54    & 8,42     & 8,54     & 8,52     & 8,50     \\ \hline
		{\bf 4}  & 5,96    & 5,96    & 5,82     & 5,88     & 5,88     & 5,88     \\ \hline
		{\bf 8}  & 3,34    & 4,89    & 4,87     & 4,80     & 4,80     & 4,80     \\ \hline
		{\bf 12} & 3,40    & 4,10    & 4,51     & 3,68     & 4,59     & 4,51     \\ \hline
		{\bf 16} & 3,45    & 3,40    & 4,27     & 2,58     & 4,28     & 4,27     \\ \hline
		{\bf 20} & 2,86    & 3,50    & 3,51     & 2,72     & 3,43     & 3,43     \\ \hline
		{\bf 24} & 2,34    & 2,89    & 2,90     & 2,87     & 2,86     & 2,86     \\ \hline
		{\bf 28} & 2,63    & 2,50    & 2,52     & 2,50     & 2,47     & 2,49     \\ \hline
		{\bf 32} & 2,65    & 2,28    & 2,23     & 2,27     & 2,23     & 2,26     \\ \hline
		{\bf 36} & 2,64    & 2,10    & 2,20     & 2,19     & 2,21     & 2,23     \\ \hline
		{\bf 40} & 2,69    & 2,16    & 2,17     & 2,17     & 2,16     & 2,16     \\ \hline
		{\bf 44} & 2,66    & 2,05    & 2,07     & 2,08     & 2,06     & 2,05*     \\ \hline
		{\bf 48} & 2,79    & 2,14    & 2,05*     & 2,05*     & 2,07     & \textbf{2,02}     \\ \hline
	\end{tabular}
	\captionsetup{justification=centering}	
	\caption{Tiempos de ejecución de la imagen \ref{buena1} con un tamaño de 1500x1500}
	\label{img1-1500}
\end{table}

En esta ocasión el mejor resultado se consigue con 48 \textit{threads} y 50 \textit{locks}. El resultado obtenido son 2,02 segundos,  un \textit{speed-up} de 7,4 y una eficiencia del 15,4\%.


\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.9\textwidth]{./imagenes/graf1-1500}
	\caption{Gráfica de los tiempos de ejecución de la imagen \ref{buena1} con un tamaño de 1500x1500}	
	\label{graf1-1500}
\end{figure}

\subsubsection{3000x3000}

\begin{table}[H]
	\centering
	\small
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		{\bf }   & {\bf 4} & {\bf 8} & {\bf 16} & {\bf 24} & {\bf 32} & {\bf 50} \\ \hline
		{\bf 1}  & 43,38   & 43,28   & 43,32    & 43,34    & 43,24    & 43,19    \\ \hline
		{\bf 2}  & 28,46   & 26,85   & 26,83    & 26,89    & 26,75    & 26,71    \\ \hline
		{\bf 4}  & 16,94   & 17,25   & 17,18    & 17,00    & 16,99    & 16,80    \\ \hline
		{\bf 8}  & 9,53    & 13,34   & 13,42    & 13,42    & 13,34    & 13,38    \\ \hline
	    {\bf 12} & 9,56    & 11,42   & 12,71    & 10,35    & 12,61    & 12,74    \\ \hline
		{\bf 16} & 9,59    & 9,50    & 12,01    & 7,36     & 11,98    & 12,00    \\ \hline
		{\bf 20} & 7,85    & 9,69    & 9,71     & 7,77     & 9,67     & 9,76     \\ \hline
		{\bf 24} & 6,81    & 8,30    & 8,29     & 8,25     & 8,20     & 8,24     \\ \hline
		{\bf 28} & 7,42    & 7,19    & 7,22     & 7,18     & 7,13     & 7,19     \\ \hline
		{\bf 32} & 7,55    & 7,06    & 7,03     & 7,04     & 6,98     & 6,83     \\ \hline
		{\bf 36} & 7,75    & 6,90    & 7,10     & 7,22     & 7,19     & 6,97     \\ \hline
		{\bf 40} & 8,00    & 7,05    & 6,93     & 6,91     & 6,90     & 6,88     \\ \hline
		{\bf 44} & 8,17    & 6,62    & 6,64     & 6,63     & 6,78     & 6,72     \\ \hline
		{\bf 48} & 8,02    & 6,64    & 6,52*     & \textbf{6,49}     & 6,75     & 6,58     \\ \hline
	\end{tabular}
	\captionsetup{justification=centering}	
	\caption{Tiempos de ejecución de la imagen \ref{buena1} con un tamaño de 3000x3000}
	\label{img1-3000}
\end{table}

El mejor resultado es de 6,49 y se alcanza con 48 \textit{threads} y 24 \textit{locks}. Se obtiene un \textit{speed-up} de 6,7 y una eficiencia del 13,9\%.

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.9\textwidth]{./imagenes/graf1-3000}
	\caption{Gráfica de los tiempos de ejecución de la imagen \ref{buena1} con un tamaño de 3000x3000}	
	\label{graf1-3000}
\end{figure}

\subsubsection{Resultado}


Los resultados de la segmentación de esta primera imagen han sido los que se muestran en \ref{result1}, donde se ha marcado la lista $L_{out}$ de color rojo y la lista $L_{in}$ de azul. Se ha conseguido obtener el contorno las islas que es lo que se esperaba.


\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.7\textwidth]{./imagenes/result1}
	\caption{Resultado de la segmentación de la imagen \ref{buena1} con un tamaño de 3000x3000}	
	\label{result1}
\end{figure}


\section{Segunda imagen}

La segunda imagen a probar será la imagen \ref{buena2}. Esta imagen tiene un contraste mayor que la anterior entre la isla y el fondo. La morfología de las islas es amorfa y algunas tienen pequeños huecos. Las islas también tienen un tamaño más grande. A continuación se presentan los resultados de las ejecuciones con diferentes tamaños de la imagen. Se ha resaltado en negrita el mejor tiempo de ejecución y se ha marcado con un asterisco los valores más cercano al óptimo conseguido.

\subsubsection{500x500}

\begin{table}[H]
	\centering
	\small
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		{\bf \backslashbox{Threads}{Locks}}   & {\bf 4} & {\bf 8} & {\bf 16} & {\bf 24} & {\bf 32} & {\bf 50} \\ \hline
		{\bf 1}  & 0,51    & 0,51    & 0,52     & 0,51     & 0,51     & 0,52     \\ \hline
		{\bf 2}  & 0,35    & 0,35    & 0,35     & 0,35     & 0,34     & 0,34     \\ \hline
		{\bf 4}  & 0,25    & 0,25    & 0,25     & 0,25     & 0,24     & 0,24     \\ \hline
		{\bf 8}  & 0,17    & 0,21    & 0,21     & 0,20     & 0,20     & 0,20     \\ \hline
		{\bf 12} & 0,17    & 0,18    & 0,19     & 0,17     & 0,19     & 0,19     \\ \hline
		{\bf 16} & 0,16    & 0,15    & 0,18     & 0,13     & 0,18     & 0,18     \\ \hline
		{\bf 20} & 0,13    & 0,15    & 0,15     & 0,13     & 0,15     & 0,15     \\ \hline
		{\bf 24} & 0,13    & 0,14    & 0,13     & 0,13     & 0,13     & 0,13     \\ \hline
		{\bf 28} & 0,16    & 0,12    & 0,12     & 0,12     & 0,12     & 0,12     \\ \hline
		{\bf 32} & 0,17    & 0,11    & 0,11     & 0,11     & 0,11     & 0,11     \\ \hline
		{\bf 36} & 0,18    & 0,12    & 0,11     & 0,11     & 0,11     & 0,11     \\ \hline
		{\bf 40} & 0,20    & 0,11    & 0,11     & \textbf{0,10}     & \textbf{0,10}     & 0,11     \\ \hline
		{\bf 44} & 0,21    & 0,13    & 0,11     & 0,11     & \textbf{0,10}     & \textbf{0,10}     \\ \hline
		{\bf 48} & 0,23    & 0,18    & 0,14     & 0,13     & 0,14     & 0,15     \\ \hline
	\end{tabular}
	\captionsetup{justification=centering}	
	\caption{Tiempos de ejecución de la imagen \ref{buena2} con un tamaño de 500x500}
	\label{img2-500}
\end{table}

Como se puede observar en la tabla \ref{img2-500} los mejores tiempos se consiguen con 40 y 44 \textit{threads} y a partir de los 24 \textit{locks}. El menor tiempo que se consigue es de 0,10 segundos, con un \textit{speed-up} de 4,9 y una eficiencia del 12,5\%.

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.7\textwidth]{./imagenes/graf2-500}
	\caption{Gráfica de los tiempos de ejecución de la imagen \ref{buena2} con un tamaño de 500x500}	
	\label{graf2-500}
\end{figure}


\subsubsection{1500x1500}

\begin{table}[H]
	\centering
	\small
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		{\bf \backslashbox{Threads}{Locks}}   & {\bf 4} & {\bf 8} & {\bf 16} & {\bf 24} & {\bf 32} & {\bf 50} \\ \hline
		{\bf 1}  & 5,45    & 5,45    & 5,46     & 5,47     & 5,46     & 5,46     \\ \hline
		{\bf 2}  & 3,56    & 3,61    & 3,57     & 3,56     & 3,54     & 3,54     \\ \hline
		{\bf 4}  & 2,63    & 2,67    & 2,65     & 2,58     & 2,58     & 2,56     \\ \hline
		{\bf 8}  & 1,68    & 2,23    & 2,20     & 2,11     & 2,11     & 2,10     \\ \hline
		{\bf 12} & 1,61    & 1,89    & 2,00     & 1,65     & 1,65     & 1,97     \\ \hline
		{\bf 16} & 1,55    & 1,50    & 1,82     & 1,22     & 1,22     & 1,83     \\ \hline
		{\bf 20} & 1,31    & 1,53    & 1,53     & 1,21     & 1,23     & 1,53     \\ \hline
		{\bf 24} & 1,15    & 1,31    & 1,31     & 1,30     & 1,31     & 1,32     \\ \hline
		{\bf 28} & 1,43    & 1,17    & 1,19     & 1,18     & 1,19     & 1,17     \\ \hline
		{\bf 32} & 1,59    & 1,12*    & 1,12*     & 1,12*     & 1,13     & \textbf{1,10}     \\ \hline
		{\bf 36} & 1,82    & 1,27    & 1,26     & 1,24     & 1,27     & 1,31     \\ \hline
		{\bf 40} & 1,97    & 1,37    & 1,39     & 1,40     & 1,37     & 1,35     \\ \hline
		{\bf 44} & 2,03    & 1,40    & 1,38     & 1,41     & 1,36     & 1,39     \\ \hline
		{\bf 48} & 2,16    & 1,80    & 1,41     & 1,37     & 1,42     & 1,42     \\ \hline
	\end{tabular}
	\captionsetup{justification=centering}	
	\caption{Tiempos de ejecución de la imagen \ref{buena2} con un tamaño de 1500x1500}
	\label{img2-1500}
\end{table}

Como se puede observar en la tabla \ref{img2-1500} el mejor resultado obtenido es de 1,10 segundos, con la combinación de 32 \textit{threads} y 50 \textit{locks}. Se consigue por lo tanto un \textit{speed-up} de 4,9 y una eficiencia del 15,5\%. 

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.9\textwidth]{./imagenes/graf2-1500}
	\caption{Gráfica de los tiempos de ejecución de la imagen \ref{buena2} con un tamaño de 1500x1500}	
	\label{graf2-1500}
\end{figure}


\subsubsection{3000x3000}

\begin{table}[H]
	\centering
	\small
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		{\bf \backslashbox{Threads}{Locks}}   & {\bf 4} & {\bf 8} & {\bf 16} & {\bf 24} & {\bf 32} & {\bf 50} \\ \hline
		{\bf 1}  & 22,29   & 22,40   & 22,25    & 22,29    & 22,27    & 22,31    \\ \hline
		{\bf 2}  & 9,64    & 9,65    & 9,83     & 9,61     & 9,58     & 9,58     \\ \hline
		{\bf 4}  & 12,42   & 12,41   & 12,64    & 12,20    & 12,21    & 12,06    \\ \hline
		{\bf 8}  & 5,88    & 7,57    & 7,61     & 7,65     & 7,53     & 7,54     \\ \hline
		{\bf 12} & 5,74    & 6,51    & 7,24     & 6,01     & 7,12     & 7,13     \\ \hline
		{\bf 16} & 5,67    & 5,43    & 6,74     & 4,48     & 6,71     & 6,72     \\ \hline
		{\bf 20} & 4,62    & 5,45    & 5,49     & 4,50     & 5,50     & 5,49     \\ \hline
		{\bf 24} & 4,07    & 4,69    & 4,72     & 4,67     & 4,66     & 4,66     \\ \hline
		{\bf 28} & 4,50    & 4,16    & 4,27     & 4,27     & 4,13*     & 4,10*     \\ \hline
		{\bf 32} & 5,08    & 4,34    & 4,15     & 4,58     & \textbf{3,85}     & 3,89*     \\ \hline
		{\bf 36} & 6,14    & 4,72    & 5,03     & 4,95     & 5,16     & 5,27     \\ \hline
		{\bf 40} & 6,65    & 5,22    & 5,25     & 5,28     & 5,25     & 5,22     \\ \hline
		{\bf 44} & 7,02    & 5,25    & 5,23     & 5,42     & 5,19     & 5,24     \\ \hline
		{\bf 48} & 7,19    & 5,45    & 5,31     & 5,23     & 5,17     & 5,39     \\ \hline
	\end{tabular}
	\captionsetup{justification=centering}	
	\caption{Tiempos de ejecución de la imagen \ref{buena2} con un tamaño de 3000x3000}
	\label{img2-3000}
\end{table}

Como se puede observar en la tabla \ref{img2-3000} el mejor resultado se obtienen con 32 \textit{threads} y a partir de los 32 \textit{locks}. El mejor resultado es de 3,85 segundos, con un \textit{speed-up} de 5,7 y una eficiencia del 18,0\%.  

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.9\textwidth]{./imagenes/graf2-3000}
	\caption{Gráfica de los tiempos de ejecución de la imagen \ref{buena2} con un tamaño de 3000x3000}	
	\label{graf2-3000}
\end{figure}


\subsubsection{Resultado}


Los resultados de la segmentación de esta segunda imagen han sido los que se muestran en \ref{result2}, donde se ha marcado la lista $L_{out}$ de color rojo y la lista $L_{in}$ de azul. Se ha conseguido obtener el contorno las islas que es lo que se esperaba.


\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.7\textwidth]{./imagenes/result2}
	\caption{Resultado de la segmentación de la imagen \ref{buena2} con un tamaño de imagen de 3000x3000}	
	\label{result2}
\end{figure}


\section{Tercera imagen}

La tercera imagen a probar será la imagen \ref{buena3} y a continuación se presentan los resultados de las ejecuciones con diferentes tamaños de la imagen. Esta imagen tiene más contraste entre el fondo y las islas que la anterior ya que es prácticamente binaria. Morfológicamente las islas son menos redondeadas y tienen aún más grietas comparadas con las de la anterior imagen. Se ha resaltado en negrita el mejor tiempo de ejecución y se ha marcado con un asterisco los valores más cercano al óptimo conseguido.

\subsubsection{Tamaño 500x500}

\begin{table}[H]
	\centering
	\small
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		{\bf \backslashbox{Threads}{Locks}}   & {\bf 4} & {\bf 8} & {\bf 16} & {\bf 24} & {\bf 32} & {\bf 50} \\ \hline
		{\bf 1}  & 0,72    & 0,73    & 0,72     & 0,73     & 0,72     & 0,72     \\ \hline
		{\bf 2}  & 0,48    & 0,48    & 0,48     & 0,48     & 0,48     & 0,48     \\ \hline
		{\bf 4}  & 0,34    & 0,34    & 0,34     & 0,35     & 0,33     & 0,33     \\ \hline
		{\bf 8}  & 0,21    & 0,28    & 0,28     & 0,27     & 0,27     & 0,27     \\ \hline
		{\bf 12} & 0,21    & 0,24    & 0,26     & 0,23     & 0,26     & 0,26     \\ \hline
		{\bf 16} & 0,20    & 0,19    & 0,24     & 0,16     & 0,24     & 0,24     \\ \hline
		{\bf 20} & 0,17    & 0,20    & 0,20     & 0,16     & 0,20     & 0,20     \\ \hline
		{\bf 24} & 0,15    & 0,17    & 0,17     & 0,17     & 0,17     & 0,17     \\ \hline
		{\bf 28} & 0,17    & 0,15    & 0,15     & 0,15     & 0,15     & 0,15     \\ \hline
		{\bf 32} & 0,17    & 0,14    & 0,14     & 0,14     & 0,14     & 0,14     \\ \hline
		{\bf 36} & 0,18    & 0,14    & 0,13     & 0,13     & 0,13     & 0,13     \\ \hline
		{\bf 40} & 0,19    & 0,12    & 0,13     & \textbf{0,12 }    & \textbf{0,12}     & \textbf{0,12}     \\ \hline
		{\bf 44} & 0,19    & 0,14    & \textbf{0,12}     & \textbf{0,12}     & \textbf{0,12}     & \textbf{0,12 }    \\ \hline
		{\bf 48} & 0,22    & 0,18    & 0,14     & 0,14     & 0,13     & 0,17     \\ \hline
	\end{tabular}
	\captionsetup{justification=centering}	
	\caption{Tiempos de ejecución de la imagen \ref{buena3} con un tamaño de 500x500}
	\label{img3-500}
\end{table}

Como se puede observar en la tabla \ref{img3-500} los mejores resultados se consiguen con 40 y 44 \textit{threads} y con mas de 8 \textit{locks}, logrando así un tiempo de 0,12 segundos, un \textit{speed-up} de 5,8 y una eficiencia del 14,6\%. 

\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.7\textwidth]{./imagenes/graf3-500}
	\caption{Gráfica de los tiempos de ejecución de la imagen \ref{buena3} con un tamaño de 500x500}	
	\label{graf3-500}
\end{figure}


\subsubsection{Tamaño 1500x1500}

\begin{table}[H]
	\centering
	\small
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		{\bf \backslashbox{Threads}{Locks}}   & {\bf 4} & {\bf 8} & {\bf 16} & {\bf 24} & {\bf 32} & {\bf 50} \\ \hline
		{\bf 1}  & 7,67    & 7,71    & 7,67     & 7,68     & 7,69     & 7,66     \\ \hline
		{\bf 2}  & 4,78    & 4,79    & 4,76     & 4,77     & 4,75     & 4,75     \\ \hline
		{\bf 4}  & 3,43    & 3,45    & 3,44     & 3,40     & 3,38     & 3,37     \\ \hline
		{\bf 8}  & 1,97    & 2,81    & 2,80     & 2,71     & 2,72     & 2,70     \\ \hline
		{\bf 12} & 1,93    & 2,32    & 2,56     & 2,16     & 2,51     & 2,49     \\ \hline
		{\bf 16} & 1,86    & 1,82    & 2,31     & 1,46     & 2,30     & 2,30     \\ \hline
		{\bf 20} & 1,56    & 1,88    & 1,87     & 1,47     & 1,86     & 1,86     \\ \hline
		{\bf 24} & 1,33    & 1,57    & 1,57     & 1,56     & 1,58     & 1,57     \\ \hline
		{\bf 28} & 1,42    & 1,37    & 1,39     & 1,39     & 1,39     & 1,38     \\ \hline
		{\bf 32} & 1,45    & 1,26    & 1,26     & 1,26     & 1,28     & 1,30     \\ \hline
		{\bf 36} & 1,58    & 1,19*    & 1,20*     & 1,26     & 1,24     & \textbf{1,18}     \\ \hline
		{\bf 40} & 1,69    & 1,35    & 1,33     & 1,33     & 1,33     & 1,33     \\ \hline
		{\bf 44} & 1,73    & 1,33    & 1,31     & 1,31     & 1,30     & 1,31     \\ \hline
		{\bf 48} & 1,79    & 1,34    & 1,33     & 1,34     & 1,33     & 1,31     \\ \hline
	\end{tabular}
	\captionsetup{justification=centering}	
	\caption{Tiempos de ejecución de la imagen \ref{buena3} con un tamaño de 1500x1500}
	\label{img3-1500}
\end{table}

La mejor respuesta temporal en este caso se consigue mediante la combinación de 36 \textit{threads} y 50 \textit{locks}. Se obtiene así un tiempo de 1,18 segundos, un \textit{speed-up} de 6,5 y una eficiencia del 18,0\%.


\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.9\textwidth]{./imagenes/graf3-1500}
	\caption{Gráfica de los tiempos de ejecución de la imagen \ref{buena3} con un tamaño de 1500x1500}	
	\label{graf3-1500}
\end{figure}


\subsubsection{Tamaño 3000x3000}


\begin{table}[H]
	\centering
	\small
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		{\bf \backslashbox{Threads}{Locks}}   & {\bf 4} & {\bf 8} & {\bf 16} & {\bf 24} & {\bf 32} & {\bf 50} \\ \hline
		{\bf 1}  & 30,89   & 30,78   & 30,84    & 30,88    & 30,77    & 30,91    \\ \hline
		{\bf 2}  & 13,23   & 13,91   & 13,19    & 13,20    & 13,43    & 13,09    \\ \hline
		{\bf 4}  & 16,18   & 16,28   & 16,33    & 16,10    & 16,00    & 15,88    \\ \hline
		{\bf 8}  & 6,78    & 9,48    & 9,54     & 9,46     & 9,44     & 9,48     \\ \hline
		{\bf 12} & 6,80    & 7,70    & 8,98     & 7,39     & 8,96     & 8,93     \\ \hline
		{\bf 16} & 6,82    & 6,68    & 8,53     & 5,32     & 8,46     & 8,50     \\ \hline
		{\bf 20} & 5,55    & 6,77    & 6,76     & 5,42     & 6,84     & 6,85     \\ \hline
		{\bf 24} & 4,81    & 5,70    & 5,69     & 5,67     & 5,74     & 5,74     \\ \hline
		{\bf 28} & 4,89    & 4,92    & 4,96     & 4,90     & 4,97     & 4,96     \\ \hline
		{\bf 32} & 4,71    & \textbf{4,44}    & 4,51*     & 4,45*     & 4,48*     & 4,46*     \\ \hline
		{\bf 36} & 5,21    & 4,88    & 4,91     & 5,01     & 4,66     & 4,61     \\ \hline
		{\bf 40} & 5,58    & 5,02    & 5,14     & 5,00     & 5,02     & 5,08     \\ \hline
		{\bf 44} & 5,69    & 5,03    & 4,90     & 4,92     & 4,91     & 4,98     \\ \hline
		{\bf 48} & 5,96    & 4,98    & 4,84     & 4,90     & 5,01     & 4,93     \\ \hline
	\end{tabular}
	\captionsetup{justification=centering}	
	\caption{Tiempos de ejecución de la imagen \ref{buena3} con un tamaño de 3000x3000}
	\label{img3-3000}
\end{table}

Como se puede observar en la tabla \ref{img3-3000} el mejor resultado se consigue con 32 \textit{threads} y 8 \textit{locks}, logrando un tiempo de 4,44 segundos, un \textit{speed-up} de 6,9 y una eficiencia del 21,7\%.


\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.8\textwidth]{./imagenes/graf3-3000}
	\caption{Gráfica de los tiempos de ejecución de la imagen \ref{buena3} con un tamaño de 3000x3000}	
	\label{graf3-3000}
\end{figure}

\subsubsection{Resultado}

Los resultados de la segmentación de esta tercera y última imagen han sido los que se muestran en \ref{result3}, donde se ha marcado la lista $L_{out}$ de color rojo y la lista $L_{in}$ de azul. Se ha conseguido obtener el contorno las islas que es lo que se esperaba.


\begin{figure}[H]
	\captionsetup{justification=centering}
	\centering
	\includegraphics[width=.7\textwidth]{./imagenes/result3}
	\caption{Resultado de la segmentación de la imagen \ref{buena3}}	
	\label{result3}
\end{figure}





\chapter{Gestión del proyecto}

\section{Gestión del alcance}

\section{Gestión del tiempo}

\section{Gestión de los riesgos}

El único riesgo más aparente que se puede producir en este proyecto es la pérdida de la memoria escrita o de la implementación paralela realizada a lo largo del proyecto. Para evitar que pueda producirse tal situación se requiere el uso de dos herramientas \textit{online}: el sistema de almacenamiento de Google, \textit{Drive}, y un sistema de gestión de versiones, en este caso \textit{Github}. Con estas dos herramienta se ha podido realizar un sistema de \textit{backup} sencillo como gestión de este riesgo. La memoria con todos sus documentos se ha guardado diariamente en el \textit{Drive} de manera que en caso de pérdida se pueda recuperar los avances de un día anterior. La implementación se ha ido creando en manera de versiones en las que se le han ido añadiendo funcionalidades extras en cada versión. Cada una de estas versiones se ha ido subiendo a la plataforma \textit{Github} del autor de esta memoria en \cite{gitHub1}. 

\section{Gestión del costes}

Los costes de este proyecto ha sido únicamente la dedicación de horas humanas con las que se ha realizado. Esto se puede ver en la tabla \ref{dedicacionTemporal}. 







\chapter{Conclusiones}

CONCLUSIONES


\section{Líneas futuras}\label{propuestaDeMejora}

A pesar de haber conseguido buenos resultados temporales de la paralelización del algoritmo \textit{level set} estos se podrían haber mejorado un poco más de haber tenido más tiempo para la realización del proyecto. A continuación se listan unas posibles mejoras o ideas futuras interesantes:

\begin{enumerate}
	\item Eliminar la compartición falsa en la memoria caché de algunas variables de la implementación que han tenido que ser creadas para poder realizar la paralelización. Por lo tanto, al ejecutar en una máquina SMP, como ciertos \textit{cores} comparten entre ellos la misma memoria caché, al realizar escrituras sobre la misma variable invalida a los demás \textit{cores} esa misma variable, por lo que tendrán que volver a cogerla de la memoria principal. Si esta operación se da muchas veces, puede suponer un sobrecoste alto a la implementación.
	\item La idea propuesta de la realización de la paralelización de los \textit{frames} de un vídeo puede llevarse a cabo mediante la librería MPI. Cada \textit{frame} se le pasaría a cada nodo del \textit{cluster} y que cada uno segmente esa imagen. En esta tarea se podrá utilizar el algoritmo desarrollado a lo largo de este proyecto en OpenMP. De esta manera, la combinación de estas dos técnicas conseguiría poder realizar la segmentación de un vídeo satisfactoriamente.
	\item El trabajo realizado en este proyecto también se podía haber desarrollado con CUDA para realizar el algoritmo en GPUs. Sin embargo, esta opción no se llevó a cabo ya que el tratamiento de las listas en CUDA es bastante complejo y no es <<natural>> comparado con el modelo de programación que se sigue en CUDA. Existen técnicas para realizar un tratamiento de estas listas más eficientemente aunque el hecho de que este tratamiento ya tenga complicación no augura muy buena eficiencia. Aparte de esto, el acceso a máquinas de pruebas podía suponer alguna complicación. Por todo ello se decidió no utilizar CUDA en ese primer momento aunque se cree que puede ser una buena opción el poder realizar este trabajo en un futuro. 
\end{enumerate}


